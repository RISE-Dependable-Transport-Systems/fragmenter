faithfulness,answer_relevancy,context_recall,context_precision,response,retrieved_contexts
1.0,0.7435887288590152,1.0,0.9999999999,"The vehicle server communicates by publishing its GPS origin (EKF reference) at 100ms intervals using `GPS_GLOBAL_ORIGIN` messages. This information is shared with the connected vehicles, allowing them to use the same local coordinate frame for ENU position representation and enabling multi-vehicle coordination.","['# Source: https://deepwiki.com/RISE-Dependable-Transport-Systems/WayWise/2-communication-layer\n\nThe Communication Layer provides bidirectional MAVLink communication between ground control stations and vehicles. It implements a three-tier architecture:\n\nThis layer handles vehicle discovery, connection health monitoring, coordinate frame transformations, telemetry streaming, command routing, and RTCM correction forwarding. The architecture supports both remote vehicle control (ground station computes autopilot) and onboard autonomous operation (vehicle runs autopilot locally).\n\nRelated pages: Vehicle Server, Vehicle Connection, MAVLink Station, Parameter Server, Autopilot Systems, Sensor Integration\n\n**Sources:** communication/vehicleconnections/mavsdkstation.h1-56 communication/vehicleconnections/vehicleconnection.h1-116 communication/vehicleserver.h1-64\n\nThe communication system follows a layered design separating discovery, abstraction, and vehicle-side handling:\n\n**Tier 1: MavsdkStation** - Listens on UDP/serial ports, discovers vehicles via heartbeat messages, maintains `QMap<int, QSharedPointer<MavsdkVehicleConnection>>`\n\nkeyed by system ID, broadcasts RTCM corrections and ENU reference to all vehicles, monitors connection health with 5-second timeout.\n\n**Tier 2: MavsdkVehicleConnection** - Abstracts vehicle-specific commands and telemetry, transforms coordinates between ENU (internal) and NED (MAVLink), delegates autopilot control to either local `WaypointFollower`\n\nor vehicle-side autopilot, initializes vehicle type (`CarState`\n\n, `TruckState`\n\n, `CopterState`\n\n) from `MAV_TYPE`\n\nand parameters.\n\n**Tier 3: MavsdkVehicleServer** - Runs onboard, exposes MAVLink server components (`TelemetryServer`\n\n, `ActionServer`\n\n, `MissionRawServer`\n\n), publishes vehicle state at 100ms via `mPublishMavlinkTimer`\n\n, intercepts messages for protocol compliance, enforces 2-second heartbeat timeout with automatic stop.\n\n**Sources:** communication/vehicleconnections/mavsdkstation.cpp9-132 communication/vehicleconnections/mavsdkvehicleconnection.cpp9-291 communication/mavsdkvehicleserver.cpp15-482\n\nThe following diagram shows the bidirectional message flow between ground station and vehicle:\n\n**Telemetry Publishing:** `mPublishMavlinkTimer`\n\nat 100ms interval publishes position/velocity/heading (ENU→NED conversion), raw GPS data if `mGNSSReceiver`\n\nis set, autopilot radius via `NAMED_VALUE_FLOAT(""AR"")`\n\n, and autopilot target point via `POSITION_TARGET_LOCAL_NED`\n\n.\n\n**Command Handling:** `mMavsdk->intercept_incoming_messages_async()`\n\ncommunication/mavsdkvehicleserver.cpp147-292 processes `MANUAL_CONTROL`\n\n, mission requests (`MISSION_REQUEST_LIST`\n\n, `MISSION_REQUEST_INT`\n\n, `MISSION_REQUEST`\n\n), and `MISSION_ACK`\n\n. Commands are routed to `mActionServer`\n\n, `mMissionRawServer`\n\n, or `handleManualControlMessage()`\n\n. Each command receives `COMMAND_ACK`\n\nresponse.\n\n**RTCM Fragmentation:** Data exceeding 180 bytes is split into fragments with sequence ID (5 bits) and fragment ID (2 bits) in flags field communication/mavsdkvehicleconnection.cpp589-611 Vehicle reassembles by checking all fragments have matching sequence ID communication/mavsdkvehicleserver.cpp332-347\n\n**Sources:** communication/mavsdkvehicleserver.cpp49-81 communication/mavsdkvehicleserver.cpp147-292 communication/mavsdkvehicleserver.cpp322-353 communication/vehicleconnections/mavsdkvehicleconnection.cpp566-615\n\nWayWise uses MAVSDK (https://mavsdk.io/) as the MAVLink protocol implementation. The system configures MAVSDK with specific component types and intercepts messages for protocol compliance:\n\nConstructor communication/mavsdkvehicleserver.cpp23-46 creates `mMavsdk`\n\nwith `ComponentType::Autopilot`\n\nand system ID from `mVehicleState->getId()`\n\n. Plugins instantiate from `mMavsdk->server_component_by_type()`\n\n: `mTelemetryServer`\n\n, `mActionServer`\n\n, `mMissionRawServer`\n\n, and `MavlinkParameterServer`\n\n(singleton). Flight mode constraints set via `mActionServer->set_allowable_flight_modes({true, true, false})`\n\n(manual/auto allowed, takeoff disabled).\n\nMAVSDK sends heartbeats automatically (configured via `config.set_always_send_heartbeats(true)`\n\n). Outgoing `HEARTBEAT`\n\nmessages are intercepted communication/mavsdkvehicleserver.cpp417-436 and modified:\n\n`type = MAV_TYPE_GROUND_ROVER`\n\nfor autopilot component`autopilot = WAYWISE_MAVLINK_AUTOPILOT_ID`\n\n(custom value)`base_mode |= MAV_MODE_FLAG_SAFETY_ARMED | MAV_MODE_FLAG_CUSTOM_MODE_ENABLED`\n\n`type = MAV_TYPE_CAMERA`\n\nfor camera component (if present)Both incoming and outgoing message interception is used:\n\n`MANUAL_CONTROL`\n\n, `MISSION_REQUEST_LIST`\n\n, `MISSION_REQUEST_INT`\n\n, `MISSION_REQUEST`\n\n, and `MISSION_ACK`\n\n`HEARTBEAT`\n\nfor protocol compliance, updates local parameter cache from `PARAM_VALUE`\n\nConstructor communication/vehicleconnections/mavsdkstation.cpp14-16 configures `mMavsdk`\n\nas `ComponentType::GroundStation`\n\nwith automatic heartbeats. Methods `startListeningUDP(uint16_t port)`\n\nand `startListeningSerial(QSerialPortInfo, int baudrate)`\n\nadd connections via `mMavsdk->add_any_connection()`\n\nor `mMavsdk->add_serial_connection()`\n\n.\n\nDiscovery communication/vehicleconnections/mavsdkstation.cpp98-131 subscribes to `mMavsdk->subscribe_on_new_system()`\n\n, inspects first `HEARTBEAT`\n\nvia temporary `MavlinkPassthrough`\n\n, creates `MavsdkVehicleConnection`\n\nif `MAV_AUTOPILOT != MAV_AUTOPILOT_INVALID`\n\n, stores in `mVehicleConnectionMap[system_id]`\n\n, and starts heartbeat monitoring.\n\n**Sources:** communication/mavsdkvehicleserver.cpp23-46 communication/mavsdkvehicleserver.cpp147-292 communication/mavsdkvehicleserver.cpp417-461 communication/vehicleconnections/mavsdkstation.cpp9-131\n\nThe communication layer implements a safety-critical heartbeat monitoring system with automatic emergency stop:\n\n**Vehicle-Side Monitoring:** `mHeartbeatTimer`\n\n(single-shot, 2000ms) resets on `HEARTBEAT`\n\nreception communication/mavsdkvehicleserver.cpp148-152 Timeout communication/mavsdkvehicleserver.cpp492-504 executes:\n\n`mHeartbeat = false`\n\nto drop incoming messages communication/mavsdkvehicleserver.cpp153-154`mWaypointFollower->stop()`\n\n`mMovementController->setDesiredSteering(0.0)`\n\nand `setDesiredSpeed(0.0)`\n\n**Station-Side Monitoring:** `mHeartbeatTimer`\n\nfires every 1000ms communication/vehicleconnections/mavsdkstation.cpp12 `on_timeout()`\n\nincrements counters in `mVehicleHeartbeatTimeoutCounters`\n\n(QVector<QPair<quint8, int>>) communication/vehicleconnections/mavsdkstation.cpp72-73 Counter resets to 0 on heartbeat communication/vehicleconnections/mavsdkstation.cpp86-91 At 5-second timeout (`HEARTBEATTIMER_TIMEOUT_SECONDS`\n\n), removes from `mVehicleConnectionMap`\n\nand emits `disconnectOfVehicleConnection(systemId)`\n\ncommunication/vehicleconnections/mavsdkstation.cpp76-80\n\nThe action server configures allowable flight modes and arming constraints communication/mavsdkvehicleserver.cpp43-46:\n\n**Sources:** communication/mavsdkvehicleserver.cpp142-152 communication/mavsdkvehicleserver.cpp492-510 communication/vehicleconnections/mavsdkstation.cpp70-91\n\nThe communication layer handles conversions between three coordinate systems (see Coordinate Systems for details):\n\n| Frame | Usage | Origin |\n|---|---|---|\nNED (North-East-Down) | Vehicle-side EKF, MAVLink telemetry | GPS origin at vehicle initialization |\nENU (East-North-Up) | System-internal representation | Shared reference set by station |\nLLH (Latitude-Longitude-Height) | Global positioning, mission items | WGS84 geodetic |\n\nThe `MavsdkVehicleServer`\n\npublishes position data in NED frame for MAVLink compliance communication/mavsdkvehicleserver.cpp50-61:\n\n```\n// Vehicle state stores position in ENU\npositionENU = vehicleState->getPosition(PosType::fused)\n// Convert to NED for MAVLink transmission\npositionNED.north = positionENU.y\npositionNED.east = positionENU.x\npositionNED.down = -positionENU.height\n```\n\n\nHeading is also converted: `yawNED = coordinateTransforms::yawENUtoNED(yawENU)`\n\ncommunication/mavsdkvehicleserver.cpp61\n\n`MavsdkVehicleConnection`\n\nsubscribes to telemetry and converts to ENU:\n\n**For MAV_TYPE_GROUND_ROVER** (assumes WayWise vehicle with shared ENU reference) communication/vehicleconnections/mavsdkvehicleconnection.cpp107-115:\n\n```\nmTelemetry->subscribe_position_velocity_ned(<FileRef file-url=""https://github.com/RISE-Dependable-Transport-Systems/WayWise/blob/d8de04ca/this"" undefined file-path=""this"">Hii</FileRef> {\nxyz_t posNED = {pv_ned.position.north_m, pv_ned.position.east_m, pv_ned.position.down_m};\npos.setXYZ(coordinateTransforms::nedToENU(posNED));\nmVehicleState->setPosition(pos);\n});\n```\n\n\n**For other types** (e.g., `MAV_TYPE_QUADROTOR`\n\n) communication/vehicleconnections/mavsdkvehicleconnection.cpp117-127:\n\n```\nmTelemetry->subscribe_position(<FileRef file-url=""https://github.com/RISE-Dependable-Transport-Systems/WayWise/blob/d8de04ca/this"" undefined file-path=""this"">Hii</FileRef> {\nllh_t llh = {position.latitude_deg, position.longitude_deg, position.absolute_altitude_m};\nxyz_t xyz = coordinateTransforms::llhToEnu(mEnuReference, llh);\npos.setX(xyz.x); pos.setY(xyz.y); pos.setHeight(xyz.z);\nmVehicleState->setPosition(pos);\n});\n```\n\n\nHeading conversion communication/vehicleconnections/mavsdkvehicleconnection.cpp129-135: `yawENU = coordinateTransforms::yawNEDtoENU(heading.heading_deg)`\n\n\nMission items uploaded to the vehicle use `MAV_FRAME_LOCAL_ENU`\n\ncommunication/mavsdkvehicleserver.cpp216 representing positions as integers scaled by 10^4 communication/mavsdkvehicleserver.cpp223-225 Downloaded mission items are similarly decoded communication/mavsdkvehicleserver.cpp581-594\n\n**Sources:** communication/mavsdkvehicleserver.cpp50-61 communication/vehicleconnections/mavsdkvehicleconnection.cpp108-127 communication/mavsdkvehicleserver.cpp210-236\n\nThe `VehicleConnection`\n\nimplements a delegation pattern that allows autopilot control to be either connection-local (running on ground station) or vehicle-based (running onboard):\n\n**Connection-Local Autopilot:** `setWaypointFollowerConnectionLocal(QSharedPointer<WaypointFollower>)`\n\ncommunication/vehicleconnections/vehicleconnection.cpp7-10 stores `mWaypointFollower`\n\n. Public methods (`startAutopilot()`\n\n, `stopAutopilot()`\n\n, `pauseAutopilot()`\n\n, `clearRoute()`\n\n, `appendToRoute()`\n\n) check `!mWaypointFollower.isNull()`\n\nand call methods directly on local instance communication/vehicleconnections/vehicleconnection.cpp25-87:\n\n**Vehicle-Based Autopilot:** Without local autopilot, calls delegate to protected virtual methods communication/vehicleconnections/vehicleconnection.h97-106 `MavsdkVehicleConnection`\n\nimplements these by sending MAVLink commands:\n\n`startAutopilotOnVehicle()`\n\nsends `MAV_CMD_DO_SET_MODE`\n\nwith mission mode communication/vehicleconnections/mavsdkvehicleconnection.cpp691-703`pauseAutopilotOnVehicle()`\n\nsends hold mode`mMissionRaw->upload_mission_async()`\n\ncommunication/vehicleconnections/mavsdkvehicleconnection.cpp714-755Same pattern applies to `FollowPoint`\n\nvia `setFollowPointConnectionLocal()`\n\ncommunication/vehicleconnections/vehicleconnection.cpp16-19 and `hasFollowPointConnectionLocal()`\n\n.\n\n**Use Cases:**\n\n`PurepursuitWaypointFollower`\n\n, sends velocity commands via `requestVelocityAndYaw()`\n\n`MavsdkVehicleServer`\n\nreceives mission, executes `WaypointFollower`\n\nonboard, controls `MovementController`\n\ndirectly**Sources:** communication/vehicleconnections/vehicleconnection.cpp7-64 communication/vehicleconnections/vehicleconnection.h70-106 communication/vehicleconnections/mavsdkvehicleconnection.cpp480-512\n\nThe `MavsdkStation`\n\ndiscovers vehicles by subscribing to new system events communication/vehicleconnections/mavsdkstation.cpp18 and waiting for heartbeats with valid autopilot IDs communication/vehicleconnections/mavsdkstation.cpp108-126:\n\n`subscribe_on_new_system`\n\ncallback`MavlinkPassthrough`\n\nto inspect first heartbeat`MAV_AUTOPILOT`\n\nis not `INVALID`\n\n, creates `MavsdkVehicleConnection`\n\n`system_id`\n\nConstructor communication/vehicleconnections/mavsdkvehicleconnection.cpp9-81 determines vehicle type from `MAV_TYPE`\n\n:\n\n| MAV_TYPE | State Class | Parameters Loaded | Additional Setup |\n|---|---|---|---|\n`MAV_TYPE_QUADROTOR` | `CopterState` | None | Subscribe to `Telemetry::LandedState` , detect gimbal component |\n`MAV_TYPE_GROUND_ROVER` | `CarState` or `TruckState` | Geometry (`VEH_LENGTH` , `VEH_WIDTH` , `VEH_WHLBASE` ), offsets | Query `VEH_WW_OBJ_TYPE` to distinguish car/truck |\n\n**Ground Rover Initialization** communication/vehicleconnections/mavsdkvehicleconnection.cpp36-76:\n\n`VEH_WW_OBJ_TYPE`\n\nvia `getIntParameterFromVehicle()`\n\n`WAYWISE_OBJECT_TYPE_TRUCK`\n\n, create `TruckState`\n\nand call `setupTruckState()`\n\n`CarState`\n\nand call `setupCarState()`\n\n`VEH_LENGTH`\n\n, `VEH_WIDTH`\n\n, `VEH_WHLBASE`\n\n, `VEH_RA2CO_X`\n\n, `VEH_RA2REO_X`\n\n`VEH_RA2HO_X`\n\n(hitch offset) and trailer parameters**Copter Initialization** communication/vehicleconnections/mavsdkvehicleconnection.cpp19-33:\n\n`CopterState(system->get_system_id())`\n\n`subscribe_component_discovered()`\n\nto detect gimbal`MavsdkGimbal`\n\nand emit `detectedGimbal()`\n\nTrucks with trailers use multi-component architecture with separate MAVLink component for trailer.\n\n**Server-Side:** `createMavsdkComponentForTrailer()`\n\ncommunication/mavsdkvehicleserver.cpp759-808 creates `mTrailerMavsdk`\n\n:\n\n`system_id`\n\n= vehicle system ID (same as truck)`component_id`\n\n= `trailerState->getId()`\n\nfrom `TRLR_COMP_ID`\n\nparameter`ComponentType::Custom`\n\nconfiguration`MAV_TYPE_GENERIC`\n\n, `MAV_AUTOPILOT_INVALID`\n\n)`NAMED_VALUE_FLOAT(""TRLR_YAW"")`\n\nat 1 Hz**Client-Side:** `setupTruckState()`\n\ncommunication/vehicleconnections/mavsdkvehicleconnection.cpp319-382 queries `TRLR_COMP_ID`\n\nparameter:\n\n`subscribe_component_discovered_id()`\n\nfor matching component ID`TrailerState(component_id)`\n\nand attach to `TruckState`\n\n`TRLR_LENGTH`\n\n, `TRLR_WIDTH`\n\n, `TRLR_WHLBASE`\n\n, `TRLR_RA2CO_X`\n\n, `TRLR_RA2REO_X`\n\n, `TRLR_RA2HO_X`\n\n`NAMED_VALUE_FLOAT`\n\nmessages from trailer component`truckState->setTrailerAngle(truckYaw - trailerYaw)`\n\non each message**Sources:** communication/vehicleconnections/mavsdkstation.cpp98-131 communication/vehicleconnections/mavsdkvehicleconnection.cpp9-81 communication/vehicleconnections/mavsdkvehicleconnection.cpp328-381 communication/mavsdkvehicleserver.cpp759-808\n\nThe station provides methods to broadcast data to all connected vehicles:\n\nGNSS RTK correction data is forwarded to all vehicles communication/vehicleconnections/mavsdkstation.cpp48-53:\n\n```\nvoid MavsdkStation::forwardRtcmData(const QByteArray &data, const int &type) {\nfor (const auto &vehicleConnection : getVehicleConnectionList())\nvehicleConnection->inputRtcmData(data);\n}\n```\n\n\nEach connection fragments and transmits the data via `GPS_RTCM_DATA`\n\nmessages communication/vehicleconnections/mavsdkvehicleconnection.cpp566-615 Fragments use sequence IDs to enable reassembly on the vehicle side.\n\nThe station sets a shared ENU reference origin for all vehicles communication/vehicleconnections/mavsdkstation.cpp55-59:\n\n```\nvoid MavsdkStation::setEnuReference(const llh_t &enuReference) {\nfor (const auto &vehicleConnection : getVehicleConnectionList())\nvehicleConnection->setEnuReference(enuReference);\n}\n```\n\n\nThis ensures all vehicles use the same local coordinate frame for ENU position representation, enabling multi-vehicle coordination.\n\nThe vehicle server publishes its GPS origin (EKF reference) at 100ms intervals communication/mavsdkvehicleserver.cpp68 via `GPS_GLOBAL_ORIGIN`\n\nmessages communication/mavsdkvehicleserver.cpp645-666 The connection polls this once at initialization communication/vehicleconnections/mavsdkvehicleconnection.cpp163 and uses it for landing target calculations communication/vehicleconnections/mavsdkvehicleconnection.cpp631\n\n**Sources:** communication/vehicleconnections/mavsdkstation.cpp48-59 communication/vehicleconnections/mavsdkvehicleconnection.cpp566-615 communication/mavsdkvehicleserver.cpp645-666\n\n**Sources:** communication/vehicleconnections/vehicleconnection.h22-113 communication/vehicleconnections/mavsdkvehicleconnection.h32-114 communication/vehicleconnections/mavsdkstation.h22-54 communication/vehicleserver.h19-61 communication/mavsdkvehicleserver.h24-69\n\nRefresh this wiki\n\nThis wiki was recently refreshed. Please wait 4 days to refresh again.', 'class MavsdkVehicleServer : public VehicleServer']"
1.0,0.9999995073775775,1.0,0.99999999995,"The purpose of the WayWise system is to serve as an effective tool in the development and testing of autonomous systems across different sectors, providing a modular, flexible, and robust platform for rapid prototyping, testing, and validation of connected autonomous vehicles and Unmanned Aerial Systems (UAS).","['M. Damschen, R. Häll and A. Mirzai Software Impacts 21 (2024) 100682\nforestry sectors. The project also seeks to enhance ICT and data man-\nagement systems to support extensive field demonstrations that address\ngenuine industrial demands. WayWise is being used to prototype func-\ntions that enhance safety-critical situational awareness of autonomous\nmobile machines in forest environments, both in model and real scale.\nResearch questions include safety and cybersecurity aspects as well as\nusing Unmanned Aerial Vehicles 3 to extend the machinery’s point of\nview for protecting humans. More details on the use case and challenges\ncan be found in [11].\nIn the SUNRISE EU project [12], which focuses on the safety\nassurance of Cooperative, Connected, and Automated Mobility (CCAM)\nsystems, WayWise plays a vital role in prototyping and demonstrations.\nThe project aims to develop a standardized safety assurance framework\nthat will undergo rigorous testing through various realistic scenarios.\nThese scenarios cover a diverse array of CCAM systems and appli-\ncations, from urban and highway navigation of personal vehicles to\nautomated parking of commercial freight trucks. Currently, WayWise\nis being utilized to develop a model-scale prototype of a truck with\na trailer for showcasing automated parking in a logistics hub as an\nintermediate step toward real-scale testing.\nAnother significant application of WayWise is in the LASH FIRE\nEU project [13], which is an international research initiative aimed at\nminimizing fire risks aboard roll-on/roll-off (ro-ro) ships. The project\nexplored the feasibility of integrating Unmanned Aerial Systems (UAS)\ninto fire and rescue operations. The objective was to prototype and\nassess feasibility and usefulness of a UAS designed for the maritime\nenvironment that could conduct automated fire patrols, assist in fire\nresource management, and perform search and rescue missions. Way-\nWise facilitated rapid prototyping of the system, providing valuable\ninsights and feedback when creating a survey targeted at professionals\nin maritime operations and UAS technology that resulted in a SWOT\n(Strengths, Weaknesses, Opportunities, Threats) analysis. The findings\nwill be presented in [14], a project report with technical details is\navailable [15].\nThe agrifoodTEF EU project [16], spanning across Europe, fo-\ncuses on assessing and validating third-party AI and Robotics solutions\nin real-world agricultural conditions. The Swedish ‘‘satellite’’ of agri-\nfoodTEF, centered around the RISE Testbed Digitalized Agriculture,\nserves as a hub for developing, testing, and demonstrating products and\nservices related to agriculture and food production. Key features of this\ntestbed include a full-scale tractor prototype called Drever 120 with an\nelectric driveline featuring four motors with 30 kW power each. Drever\n120 was automated using WayWise and demonstrated together with a\nprototype automated battery swap system in front of all EU agriculture\nministers [17].\nThrough these diverse projects, WayWise has demonstrated its util-\nity and adaptability in various applications, reinforcing its role as an\neffective tool in the development and testing of autonomous systems\nacross different sectors.\n3. Future directions and conclusion\nWayWise has proven to be an effective tool in autonomous vehicle\nresearch, providing a modular, flexible, and robust platform for rapid\nprototyping, testing, and validation of connected autonomous vehicles\nand UASs. Built with C++ and Qt, WayWise integrates vehicle dy-\nnamics, control systems, communication protocols, and user interface\ncomponents, supporting diverse research and development needs with\nCOTS hardware compatibility and advanced sensor integration. Its\neffectiveness is showcased in projects like AGRARSENSE, SUNRISE,\nLASH FIRE, and agrifoodTEF, enhancing situational awareness, safety,\nand operational efficiency.\n3 Implemented using PX4 [10] and communicating to WayWise via\nMAVLINK.\nLooking ahead, the main developments on control station and ve-\nhicles side are multi vehicle support and ROS2 [18] integration, re-\nspectively. ControlTower recently received support to manage multiple\nvehicles including autopilot control and monitoring. This enables inves-\ntigating research questions where vehicles interact more tightly, e.g., to\nincrease worksite safety as in the AGRARSENSE project.\nOn the vehicle side, our recently established WayWiseR 4 project\nintegrates the rapid prototyping capability of WayWise with ROS2.', 'M. Damschen, R. Häll and A. Mirzai Software Impacts 21 (2024) 100682\nFig. 1. Summary of WayWise’s capabilities including control station and various types of vehicles.\nRCCar1 and ControlTower2 are our flagship projects for WayWise,\nwhere RCCar represents the vehicle side and ControlTower the control\nsystem desktop application.\n1.1. Key features\nWayWise is organized into several components (highlighted in bold\nin the following) to address different aspects of autonomous vehicle\ndevelopment. At its foundation, the core component includes funda-\nmental classes and headers for tasks such as storing positions and\ntransforming coordinates, with support for both relative coordinates in\nEast-North-Up (ENU) and global coordinates in longitude and latitude,\nensuring precise geospatial handling. Communication is a crucial\naspect, where WayWise handles both external and internal commu-\nnication needs. Externally, it mainly uses the MAVLINK protocol im-\nplemented via MAVSDK [1], enabling robust and flexible interactions\nbetween vehicles and control stations. WayWise is generally proto-\ncol agnostic, though. For example, it additionally supports ISO/TS\n22133 [2], a protocol for active safety and automated vehicle testing.\nThe support was contributed by AstaZero, a full-scale test environ-\nment for autonomous transport systems in Sweden [3]. For internal\ncommunication in more complex vehicles, WayWise supports vehicle\ncommunication to lower-level controls using the CANopen protocol\nthrough the Lely CANopen library [4].\nThe vehicles component comprises classes that store the state of\ndifferent vehicle types, facilitating straight forward kinematic simu-\nlations within a desktop application or on the vehicles themselves.\nVarious vehicle types, including rc cars, drones, and full-sized machin-\nery are supported. Sensor integration is another vital component, and\nWayWise includes broad support for sensors such as positioning using\nGNSS (including Real-Time Kinematic (RTK) with a focus on u-blox\nreceivers [5]), IMUs, Ultra Wide Band (UWB, using Pozyx [6]). Further,\nDepthAI [7] has been integrated to prototype AI-enabled functionality\nlike keeping a safe distance from or following persons.\nAutopilot defines a generic interface, ‘‘WaypointFollower’’, for im-\nplementing autopilot functionalities. Notable implementations include\na pure pursuit-based autopilot [8] and the ‘‘MultiWaypointFollower’’,\n1 https://github.com/RISE-Dependable-Transport-Systems/RCCar\n2 https://github.com/RISE-Dependable-Transport-Systems/ControlTower\nwhich allows for switching between multiple WaypointFollowers. This\nflexibility supports complex use cases such as following a route, pausing\nfor charging, and resuming the route. Also following moving points\n(like detected persons) is implemented here. WayWise further provides\nan easy-to-integrate logger, allowing data from vehicles to be effi-\nciently logged and transmitted to the control station for analysis and\ndebugging.\nAdditionally, the library includes user interface building blocks\nfor creating desktop applications, most notably a map module for dis-\nplaying vehicle positions on OpenStreetMap with modular extensions\nfor creating routes and tracing movements. It further features route\nplanning using a configurable route generator currently focusing on\nagricultural applications.\n1.2. Technological advancements\nWayWise demonstrates technological advancements in autonomous\nvehicle research through its modular and flexible architecture. Built\non C++ and Qt, it allows seamless integration of vehicle dynamics,\ncontrol systems, and communication protocols. It supports a wide range\nof vehicles, from model-sized cars to full-sized machinery, and provides\neffective means for both external (MAVLINK, ISO/TS 22133) and inter-\nnal (CANopen) communications. Advanced sensor integration (GNSS,\nIMUs, UWB, DepthAI) enhances environmental perception and navi-\ngation, while its ‘‘WaypointFollower’’ autopilot functionalities support\ncomplex use cases effectively. Compatible with COTS hardware and of-\nfering cross-platform capabilities, WayWise provides a comprehensive\ntoolset for rapid prototyping, making it a vital resource for developing\nand testing autonomous systems across various applications. Its design\nensures that it can meet diverse research and development needs,\nsupporting the exploration and validation of new technologies and\nmethodologies in the autonomous systems domain.\n2. Case studies and impact\nWayWise has been integral to various research projects, showcasing\nits versatility and effectiveness in real-world scenarios.']"
