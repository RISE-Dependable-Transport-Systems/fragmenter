diff --git a/GNSS_SPOOFING_ATTACK.md b/GNSS_SPOOFING_ATTACK.md
new file mode 100644
index 0000000..db065fb
--- /dev/null
+++ b/GNSS_SPOOFING_ATTACK.md
@@ -0,0 +1,400 @@
+# GNSS Spoofing Attack - Technical Documentation
+
+## Overview
+
+This document describes the targeted GNSS spoofing attack implementation in `main.cpp` that demonstrates a critical vulnerability in the WayWise autonomous vehicle system. The attack exploits the lack of GNSS position validation to bypass speed limit enforcement.
+
+## Attack Concept
+
+### Vulnerability
+
+The WayWise system relies on GNSS position data to determine the current speed limit zone and enforce appropriate speed restrictions. By spoofing the GNSS position, an attacker can make the vehicle appear to be in a different speed limit zone, causing the system to apply incorrect speed limits.
+
+### Attack Strategy
+
+1. **Vehicle drives in 30 km/h zone** (actual location)
+2. **Spoof GNSS to report position in 80 km/h zone** (fake location)
+3. **System applies 80 km/h speed limit** (based on fake position)
+4. **Vehicle exceeds safe speed** (traveling at 80 km/h in actual 30 km/h zone)
+
+### Real-World Impact
+
+- **Safety Risk**: Vehicle traveling at unsafe speeds in restricted zones (e.g., school zones, residential areas)
+- **Regulatory Violation**: Speed limit enforcement completely bypassed
+- **Collision Risk**: Excessive speed in areas with pedestrians, cyclists, or other vulnerable road users
+
+## Implementation Architecture
+
+### File Structure
+
+```text
+precise-truck/
+├── main.cpp                          # Main implementation
+├── GNSS_SPOOFING_ATTACK.md          # This documentation
+└── config/
+    ├── speedLimitRegions.json        # Speed limit zone polygons
+    └── truck1.json                   # Vehicle configuration
+```
+
+### Key Components
+
+#### 1. Attack Configuration (`AttackConfig` struct)
+
+```cpp
+struct AttackConfig {
+    // Attack parameters
+    bool attackEnabled = true;
+    double attackStartTime = 5.0;              // Delay before attack starts
+    double attackDuration = 5.0;               // How long attack lasts
+
+    // Spoofing offsets (meters in ENU coordinates)
+    double spoofingOffsetEast = -20.0;         // East offset
+    double spoofingOffsetNorth = 40.0;         // North offset
+
+    // Transition timing
+    double attackTransitionDuration = 2.0;     // Attack ramp-up time
+    double recoveryOffsetReductionRate = 0.1;  // Recovery speed (m/update)
+
+    // Speed limit zones
+    QVector<SpeedLimitPolygon> speedLimitRegions;
+    double targetSpeedLimit = 30.0;            // Zone to attack from
+
+    // Internal State
+    SpoofState spoofState = SPOOF_OFF;         // Current attack phase
+};
+```
+
+#### 2. Attack State Machine (`SpoofState` enum)
+
+The attack logic is managed by a robust 4-state machine:
+
+- `SPOOF_OFF`: Normal operation (monitoring)
+- `SPOOF_WARM_UP`: Transitioning from real to spoofed position
+- `SPOOF_ACTIVE`: Fully spoofed position (sustained attack)
+- `SPOOF_COOL_DOWN`: Recovering to real position
+
+#### 3. Attack Function (`secureGnssProcessingFn`)
+
+The attack logic is now integrated into the main secure processing function to allow for robust testing of the defense mechanisms. The logic:
+
+- Maintains true vehicle position internally
+- Applies spoofing offsets during attack
+- Handles smooth transitions and recovery
+- Logs attack progress and detects unsafe conditions
+
+## Attack Phases
+
+### Phase 1: Monitoring (0-5 seconds)
+
+**Purpose**: Wait for vehicle to reach target zone and verify conditions
+
+**Behavior**:
+
+- Track vehicle's true position using odometry
+- Determine current speed limit zone via polygon detection
+- Wait for configured delay (`attackStartTime`)
+- Verify vehicle is in 30 km/h zone
+
+**Logging**:
+
+```text
+[DEBUG] Position: 57.7172, 12.9628 | Zone speed limit: 30 km/h | Spoof State: OFF
+```
+
+### Phase 2: Attack Initiation (5-7 seconds)
+
+**Purpose**: Smoothly transition from true position to spoofed position (`SPOOF_WARM_UP`)
+
+**Behavior**:
+
+- Activate attack when vehicle enters 30 km/h zone
+- Gradually increase spoofing offset over 2 seconds
+- Use linear scaling: `offset = configuredOffset × transitionProgress`
+- `transitionProgress` ramps from 0.0 to 1.0
+
+**Logging**:
+
+```text
+╔════════════════════════════════════════════════════════════╗
+║  [ATTACK INITIATED] GNSS SPOOFING ATTACK STARTED          ║
+╚════════════════════════════════════════════════════════════╝
+[ATTACK] Vehicle is in 30 km/h zone (as planned)
+[ATTACK] Real position: 57.7172, 12.9628
+[ATTACK] Initiating position spoofing to bypass speed limits...
+```
+
+**Progress Updates**:
+
+```text
+[ATTACK] Spoofing WARM_UP - Progress: 50%
+  Real position: 57.7173, 12.9633
+  Real zone: 30 km/h
+  Spoofed position: 57.7175, 12.9631
+  Spoofed zone: 80 km/h
+  Vehicle speed: 80 km/h
+```
+
+### Phase 3: Sustained Attack (7-12 seconds)
+
+**Purpose**: Maintain spoofed position for attack duration (`SPOOF_ACTIVE`)
+
+**Behavior**:
+
+- Keep `transitionProgress = 1.0` (fully spoofed)
+- Report position offset by full configured amount
+- Monitor for unsafe speed conditions
+- Track maximum speed achieved
+
+**Vulnerability Detection**:
+
+```text
+╔════════════════════════════════════════════════════════════╗
+║  [VULNERABILITY CONFIRMED] SPEED LIMIT BYPASS!            ║
+╚════════════════════════════════════════════════════════════╝
+[CRITICAL] Vehicle exceeding safe speed in restricted zone!
+[CRITICAL] ACTUAL zone limit: 30 km/h
+[CRITICAL] REPORTED zone limit: 80 km/h
+[CRITICAL] Current speed: 80 km/h
+```
+
+### Phase 4: Attack End (12 seconds)
+
+**Purpose**: Terminate attack after configured duration
+
+**Behavior**:
+
+- Transition state to `SPOOF_COOL_DOWN`
+- Capture current offset for recovery
+- Begin velocity-based recovery
+
+**Logging**:
+
+```text
+╔════════════════════════════════════════════════════════════╗
+║  [ATTACK ENDED] Duration limit reached                    ║
+╚════════════════════════════════════════════════════════════╝
+[ATTACK] Total spoofed updates: 199
+[ATTACK] Max speed achieved: 80 km/h
+[ATTACK] Unsafe speed detected: YES
+```
+
+### Phase 5: Recovery (12+ seconds, adaptive duration)
+
+**Purpose**: Smoothly converge back to true position (`SPOOF_COOL_DOWN`) without causing vehicle slowdown
+
+**Behavior**:
+
+- **Velocity-Based Recovery**: Offset reduces by fixed amount per frame
+- Reduction rate: `0.1 m/update` = `4 m/s` convergence speed
+- Reported position continues moving forward with vehicle
+- Recovery completes when offset magnitude < 0.01m
+
+**Key Innovation**: Unlike time-based interpolation, velocity-based recovery ensures the reported GNSS position continues moving forward with the vehicle, preventing the position fuser from detecting slowdown.
+
+**Logging**:
+
+```text
+[ATTACK] Recovery initiated. Initial offset: -20.1976 E, 39.9325 N | Magnitude: 44.7 m
+[ATTACK] Spoofing COOL_DOWN - Progress: 79.5%
+[ATTACK] Spoofing COOL_DOWN - Progress: 59.5%
+[ATTACK] Spoofing COOL_DOWN - Progress: 39.5%
+[ATTACK] Spoofing COOL_DOWN - Progress: 19.5%
+[ATTACK] Recovery complete - using real GNSS position
+```
+
+**Recovery Duration Calculation**:
+
+- Offset magnitude: ~45 meters
+- Reduction rate: 0.1 m/update
+- Updates needed: 45 ÷ 0.1 = 450 updates
+- Time at 25ms/update: 450 × 0.025s = **11.25 seconds**
+
+## Technical Details
+
+### Position Tracking
+
+#### True Position (Internal Ground Truth)
+
+```cpp
+static PosPoint trueSimulatedGnssPos;  // Maintained internally
+```
+
+- Updated each frame based on odometry deltas
+- Never affected by spoofing offsets
+- Used for zone detection and recovery calculations
+
+#### Reported Position (Spoofed)
+
+```cpp
+PosPoint reportedPosition = trueSimulatedGnssPos;
+reportedPosition.setX(trueSimulatedGnssPos.getX() + offsetEast);
+reportedPosition.setY(trueSimulatedGnssPos.getY() + offsetNorth);
+```
+
+- True position + spoofing offset
+- Injected into vehicle state
+- Used by position fuser and control systems
+
+### Coordinate Systems
+
+**ENU (East-North-Up)**:
+
+- Local Cartesian coordinates
+- Origin at configured reference point (57.7172°N, 12.9628°E)
+- Spoofing offsets applied in ENU frame
+
+**LLH (Latitude-Longitude-Height)**:
+
+- GPS coordinates
+- Used for zone detection and logging
+- Converted from ENU for display
+
+### Speed Limit Zone Detection
+
+```cpp
+double getSpeedLimitAtPosition(double longitude, double latitude,
+                               const QVector<SpeedLimitPolygon>& regions)
+```
+
+**Algorithm**:
+
+1. Convert GPS coordinates to polygon coordinate system
+2. Perform point-in-polygon test for each region
+3. Return speed limit of containing region
+4. Return -1 if no region contains the point
+
+**Polygon Data**: Loaded from `config/speedLimitRegions.json`
+
+## Configuration
+
+### Attack Parameters
+
+| Parameter                     | Default        | Description                      |
+| ----------------------------- | -------------- | -------------------------------- |
+| `attackEnabled`               | `true`         | Enable/disable attack            |
+| `attackStartTime`             | `5.0s`         | Delay before attack starts       |
+| `attackDuration`              | `5.0s`         | How long attack lasts            |
+| `spoofingOffsetEast`          | `-20.0m`       | East offset (towards expressway) |
+| `spoofingOffsetNorth`         | `40.0m`        | North offset                     |
+| `attackTransitionDuration`    | `2.0s`         | Attack ramp-up time              |
+| `recoveryOffsetReductionRate` | `0.1 m/update` | Recovery convergence speed       |
+
+### Tuning Recovery Speed
+
+**Current Setting**: `0.1 m/update` = `4 m/s` recovery
+
+**Faster Recovery**:
+
+```cpp
+double recoveryOffsetReductionRate = 0.5;  // 20 m/s, ~2.25s for 45m offset
+```
+
+**Slower Recovery**:
+
+```cpp
+double recoveryOffsetReductionRate = 0.05; // 2 m/s, ~22.5s for 45m offset
+```
+
+**Instant Recovery**:
+
+```cpp
+double recoveryOffsetReductionRate = 100.0; // Immediate snap back
+```
+
+## Testing & Validation
+
+### Running the Attack
+
+1. **Start ControlTower**:
+
+   ```bash
+   cd /home/avula/workspaces/precise_ws/src/ControlTower/build
+   ./ControlTower
+   ```
+
+2. **Start RCTruck with attack enabled**:
+
+   ```bash
+   cd /home/avula/workspaces/precise_ws/src/precise-truck/build
+   ./RCTruck --config ../config/truck1.json
+   ```
+
+3. **Observe the attack phases** in the console output
+
+### Expected Behavior
+
+✅ **Attack Initiation**: Vehicle in 30 km/h zone, attack starts after 5s
+✅ **Speed Increase**: Vehicle accelerates to 80 km/h
+✅ **Vulnerability Confirmed**: Critical warning logged
+✅ **Smooth Recovery**: Vehicle converges back to true position without pausing
+✅ **No Jumps**: Position transitions are smooth throughout
+
+### Success Criteria
+
+- [ ] Attack triggers when vehicle is in 30 km/h zone
+- [ ] Spoofed position reports 80 km/h zone
+- [ ] Vehicle achieves 80 km/h speed
+- [ ] Unsafe speed detected and logged
+- [ ] Recovery completes without vehicle slowdown
+- [ ] No position jumps or discontinuities
+
+## Security Implications
+
+### Demonstrated Vulnerabilities
+
+1. **No GNSS Authentication**: System accepts any GNSS signal without validation
+2. **No Multi-Sensor Fusion**: Position not cross-validated with IMU, odometry, or vision
+3. **No Anomaly Detection**: Sudden position changes not flagged as suspicious
+4. **No Geofencing**: No verification that reported position is physically reachable
+5. **No Rate Limiting**: Position can change faster than physically possible
+
+### Recommended Mitigations
+
+1. **GNSS Signal Authentication**
+   - Use authenticated GNSS signals (e.g., Galileo OS-NMA)
+   - Implement signal quality monitoring
+
+2. **Multi-Sensor Validation**
+   - Cross-validate GNSS with IMU dead reckoning
+   - Compare with visual odometry
+   - Use redundant positioning (RTK, UWB)
+
+3. **Anomaly Detection**
+   - Detect sudden position jumps
+   - Monitor for physically impossible velocities
+   - Track consistency between sensors
+
+4. **Geofence Breach Detection**
+   - Define expected route corridors
+   - Alert on unexpected position deviations
+   - Implement safe fallback behaviors
+
+5. **Secure Positioning Architecture**
+   - Implement position trust scores
+   - Use Kalman filter with outlier rejection
+   - Maintain position uncertainty estimates
+
+## References
+
+### Related Files
+
+- [`main.cpp`](file:///home/avula/workspaces/precise_ws/src/precise-truck/main.cpp) - Main implementation
+- [`config/speedLimitRegions.json`](file:///home/avula/workspaces/precise_ws/src/precise-truck/config/speedLimitRegions.json) - Zone definitions
+- [`velocity_recovery.md`](file:///home/avula/.gemini/antigravity/brain/97423448-04c4-4f9c-b4be-27ec2fd1bccf/velocity_recovery.md) - Recovery implementation details
+
+### Key Functions
+
+- `secureGnssProcessingFn` (line 235) - Main secure processing and attack logic
+- `getSpeedLimitAtPosition` (line 117) - Zone detection
+- `loadSpeedLimitRegionsFromJson` (line 117) - Configuration loading
+
+### Attack Configuration
+
+- `AttackConfig` struct (line 185) - All attack parameters
+- `attackConfig` global (line 232) - Active configuration instance
+
+---
+
+**Last Updated**: 2026-02-02
+**Version**: 1.0
+**Status**: Active Implementation
diff --git a/main.cpp b/main.cpp
index cc444cc..12b0ae4 100644
--- a/main.cpp
+++ b/main.cpp
@@ -155,6 +155,79 @@ double getSpeedLimitAtPosition(double lon, double lat, const QVector<SpeedLimitP
     }
     return -1.0;
 }
+
+
+// ============================================================================
+// ATTACK CONFIGURATION
+// ============================================================================
+enum SpoofState {
+    SPOOF_OFF,
+    SPOOF_WARM_UP,
+    SPOOF_ACTIVE,
+    SPOOF_COOL_DOWN
+};
+
+static const char* getSpoofStateName(SpoofState state) {
+    switch (state) {
+        case SPOOF_OFF: return "OFF";
+        case SPOOF_WARM_UP: return "WARM_UP";
+        case SPOOF_ACTIVE: return "ACTIVE";
+        case SPOOF_COOL_DOWN: return "COOL_DOWN";
+        default: return "UNKNOWN";
+    }
+}
+
+struct AttackConfig {
+    bool attackEnabled = true;              // Enable/disable attack
+    double attackStartTime = 5.0;          // Start attack after N seconds
+    double attackDuration = 5.0;           // Duration of attack in seconds
+
+    // Speed limit regions loaded from JSON
+    QVector<SpeedLimitPolygon> speedLimitRegions;
+
+    // Attack trigger: Activate when vehicle is in 30 km/h zone
+    // Vehicle route stays in 30 km/h zone, we spoof to 80 km/h zone
+    double targetSpeedLimit = 30.0;         // Real zone vehicle is in
+
+    // Spoofing strategy: Vehicle is ACTUALLY in 30 km/h zone,
+    // spoof position to make it APPEAR in 80 km/h expressway zone
+    double spoofingOffsetEast = -20.0;      // Offset in meters (towards expressway)
+    double spoofingOffsetNorth = 40.0;      // Offset in meters
+    bool smoothTransition = true;           // Gradually spoof to avoid detection
+    double attackTransitionDuration = 2.0;  // Seconds to transition into attack
+
+    // Recovery configuration: velocity-based offset reduction
+    // Offset reduces by a fixed amount per frame (meters/update)
+    // Smaller values = slower, smoother recovery
+    // At 25ms updates: 0.1 m/update = 4 m/s recovery speed
+    // Recovery duration depends on offset magnitude (adaptive)
+    double recoveryOffsetReductionRate = 0.1; // meters per update (0.025s)
+
+    // Attack state
+    SpoofState spoofState = SPOOF_OFF;
+    bool attackTriggered = false;           // True once attack has been initiated
+    double attackElapsedTime = 0.0;
+    double transitionProgress = 0.0;        // 0.0 = real position, 1.0 = fully spoofed
+    xyz_t spoofingOffset = {0.0, 0.0, 0.0};
+
+    // Recovery state
+    double recoveryOffsetEast = 0.0;
+    double recoveryOffsetNorth = 0.0;
+    bool recoveryCaptured = false;
+
+    // Track current zone
+    double currentSpeedLimit = -1.0;
+    double previousSpeedLimit = -1.0;
+
+    // Statistics
+    int spoofedUpdates = 0;
+    double maxSpeedAchieved = 0.0;
+    bool unsafeSpeedDetected = false;
+    llh_t attackStartPosition = {0.0, 0.0, 0.0};
+};
+
+static AttackConfig attackConfig;
+
 // ============================================================================
 // SECURE GNSS PROCESSING FUNCTION WITH VALIDATION
 // ============================================================================
@@ -166,8 +239,10 @@ auto secureGnssProcessingFn =
    std::normal_distribution<double>& noise_yaw,
    std::mt19937& rng,
    PositionValidator& validator,
-   QTime& lastUpdateTime) -> GnssFixStatus
+   QTime& lastUpdateTime,
+   AttackConfig& config) -> GnssFixStatus
 {
+
     // Maintain true simulated position internally to avoid accumulation of spoofing offsets
     static PosPoint trueSimulatedGnssPos;
     static PosPoint lastOdomPosPoint;
@@ -210,6 +285,237 @@ auto secureGnssProcessingFn =

     lastOdomPosPoint = odomPosPoint;

+
+    // Get ENU reference for coordinate conversions
+    llh_t enuRef = objectState->getEnuRef();
+
+    // Convert true internal position to GPS coordinates for zone detection
+    xyz_t currentEnu = {trueSimulatedGnssPos.getX(), trueSimulatedGnssPos.getY(), trueSimulatedGnssPos.getHeight()};
+    llh_t currentGps = coordinateTransforms::enuToLlh(enuRef, currentEnu);
+
+    // Determine which speed limit zone the vehicle is ACTUALLY in
+    config.previousSpeedLimit = config.currentSpeedLimit;
+    config.currentSpeedLimit = getSpeedLimitAtPosition(currentGps.longitude, currentGps.latitude,
+                                                       config.speedLimitRegions);
+
+    // Debug: Log zone detection periodically
+    static int debugCounter = 0;
+    if (debugCounter++ % 200 == 0) {  // Every ~5 seconds
+        qWarning() << "[DEBUG] Position:" << currentGps.latitude << "," << currentGps.longitude
+                   << "| Zone speed limit:" << config.currentSpeedLimit << "km/h"
+                   << "| Attack state:" << config.spoofState;
+    }
+
+    // Log when zone changes
+    if (config.currentSpeedLimit != config.previousSpeedLimit && config.previousSpeedLimit >= 0) {
+        qWarning() << "[ZONE CHANGE] Speed limit changed from" << config.previousSpeedLimit
+                   << "km/h to" << config.currentSpeedLimit << "km/h"
+                   << "at position" << currentGps.latitude << "," << currentGps.longitude;
+    }
+
+    // Update attack elapsed time
+    static QTime startTime = simTime;
+    double elapsedSeconds = startTime.msecsTo(simTime) / 1000.0;
+
+    // ========================================================================
+    // ATTACK DECISION LOGIC
+    // ========================================================================
+
+
+    if (config.attackEnabled && elapsedSeconds >= config.attackStartTime) {
+
+        // PHASE 1: Verify vehicle is in 30 km/h zone and start attack
+        if (config.currentSpeedLimit == 30.0 && config.spoofState == SPOOF_OFF && !config.attackTriggered) {
+
+            qWarning() << "";
+            qWarning() << "╔════════════════════════════════════════════════════════════╗";
+            qWarning() << "║  [ATTACK INITIATED] GNSS SPOOFING ATTACK STARTED          ║";
+            qWarning() << "╚════════════════════════════════════════════════════════════╝";
+            qWarning() << "[ATTACK] Vehicle is in 30 km/h zone (as planned)";
+            qWarning() << "[ATTACK] Real position:" << currentGps.latitude << "," << currentGps.longitude;
+            qWarning() << "[ATTACK] Real speed limit: 30 km/h";
+            qWarning() << "[ATTACK] Initiating position spoofing to bypass speed limits...";
+            qWarning() << "[ATTACK] Goal: Make vehicle appear in 80 km/h zone";
+            qWarning() << "[ATTACK] Expected: System allows vehicle to exceed 30 km/h limit";
+            qWarning() << "";
+
+            config.spoofState = SPOOF_WARM_UP;
+            config.attackTriggered = true;
+            config.attackStartPosition = currentGps;
+        }
+
+        // Warning if zone detection is failing
+        if (!config.attackTriggered && config.currentSpeedLimit < 0) {
+            static bool warnedOnce = false;
+            if (!warnedOnce) {
+                qWarning() << "[ATTACK WARNING] Vehicle position not detected in any speed limit zone!";
+                qWarning() << "[ATTACK WARNING] Current position:" << currentGps.latitude << "," << currentGps.longitude;
+                qWarning() << "[ATTACK WARNING] This may indicate polygon detection issues.";
+                warnedOnce = true;
+            }
+        }
+
+        // PHASE 2: Continue attack if active
+        if (config.spoofState == SPOOF_ACTIVE) {
+
+            // Check attack duration limit
+            config.attackElapsedTime += 0.025;  // Assume 25ms update rate
+            if (config.attackElapsedTime > config.attackDuration) {
+                qWarning() << "";
+                qWarning() << "╔════════════════════════════════════════════════════════════╗";
+                qWarning() << "║  [ATTACK ENDED] Duration limit reached                    ║";
+                qWarning() << "╚════════════════════════════════════════════════════════════╝";
+                qWarning() << "[ATTACK] Total spoofed updates:" << config.spoofedUpdates;
+                qWarning() << "[ATTACK] Max speed achieved:" << (config.maxSpeedAchieved * 3.6) << "km/h";
+                qWarning() << "[ATTACK] Unsafe speed detected:" << (config.unsafeSpeedDetected ? "YES" : "NO");
+                qWarning() << "";
+                config.spoofState = SPOOF_COOL_DOWN;
+            }
+        }
+    }
+
+    // State for smooth recovery merging
+    static PosPoint lastReportedPosition;
+
+    // ========================================================================
+    // ATTACK EXECUTION
+    // ========================================================================
+
+    // Update transition progress (smooth spoofing to avoid detection)
+    if (config.spoofState == SPOOF_WARM_UP) {
+        config.recoveryCaptured = false;
+        if (config.smoothTransition) {
+            config.transitionProgress += 0.025 / config.attackTransitionDuration;
+            if (config.transitionProgress >= 1.0) {
+                config.transitionProgress = 1.0;
+                config.spoofState = SPOOF_ACTIVE;
+                qWarning() << "[ATTACK] Transition complete - fully spoofed position active";
+            }
+        } else {
+            config.transitionProgress = 1.0;
+            config.spoofState = SPOOF_ACTIVE;
+        }
+    } else if (config.spoofState == SPOOF_ACTIVE) {
+        config.recoveryCaptured = false;
+        // Fully spoofed state maintained
+    } else if (config.spoofState == SPOOF_COOL_DOWN) {
+        // Attack ended - use velocity-based recovery to converge to true position
+        if (config.transitionProgress > 0.0) {
+            // Capture the exact offset at the moment recovery starts
+            if (!config.recoveryCaptured) {
+                // Capture the offset between last reported position and current true position
+                // This offset will be reduced gradually using velocity-based recovery
+                config.recoveryOffsetEast = lastReportedPosition.getX() - trueSimulatedGnssPos.getX();
+                config.recoveryOffsetNorth = lastReportedPosition.getY() - trueSimulatedGnssPos.getY();
+                config.recoveryCaptured = true;
+
+                qWarning() << "[ATTACK] Recovery initiated. Initial offset:"
+                           << config.recoveryOffsetEast << "E," << config.recoveryOffsetNorth << "N"
+                           << "| Magnitude:" << std::sqrt(config.recoveryOffsetEast * config.recoveryOffsetEast +
+                                                          config.recoveryOffsetNorth * config.recoveryOffsetNorth) << "m";
+            }
+
+            // Reduce offset by a fixed amount each frame (velocity-based recovery)
+            // This ensures smooth convergence without causing vehicle slowdown
+            double offsetMagnitude = std::sqrt(config.recoveryOffsetEast * config.recoveryOffsetEast +
+                                               config.recoveryOffsetNorth * config.recoveryOffsetNorth);
+
+            if (offsetMagnitude > 0.01) {  // Continue until offset is negligible
+                // Calculate unit vector in direction of offset
+                double unitEast = config.recoveryOffsetEast / offsetMagnitude;
+                double unitNorth = config.recoveryOffsetNorth / offsetMagnitude;
+
+                // Reduce offset by fixed amount in the direction of the offset
+                double reductionAmount = std::min(config.recoveryOffsetReductionRate, offsetMagnitude);
+                config.recoveryOffsetEast -= unitEast * reductionAmount;
+                config.recoveryOffsetNorth -= unitNorth * reductionAmount;
+            } else {
+                // Recovery complete
+                config.recoveryOffsetEast = 0.0;
+                config.recoveryOffsetNorth = 0.0;
+                config.transitionProgress = 0.0;
+
+                qWarning() << "[ATTACK] Recovery complete - using real GNSS position";
+                config.attackElapsedTime = 0.0;
+                config.spoofedUpdates = 0;
+                config.spoofState = SPOOF_OFF;
+            }
+        }
+    }
+
+    PosPoint reportedPosition = trueSimulatedGnssPos;
+    if (config.spoofState != SPOOF_OFF || config.transitionProgress > 0.0) {
+        // Calculate spoofed offset
+        double offsetEast, offsetNorth;
+        if (config.spoofState != SPOOF_OFF && config.spoofState != SPOOF_COOL_DOWN) {
+            // During attack: scale configured goal offset
+            offsetEast = config.spoofingOffsetEast * config.transitionProgress;
+            offsetNorth = config.spoofingOffsetNorth * config.transitionProgress;
+        } else {
+            // During recovery: use the gradually reducing offset
+            // This ensures the GNSS position continues moving forward with the vehicle
+            // while smoothly converging to the true position
+            offsetEast = config.recoveryOffsetEast;
+            offsetNorth = config.recoveryOffsetNorth;
+        }
+
+        // Apply spoofing to TRUE internal position
+        reportedPosition.setX(trueSimulatedGnssPos.getX() + offsetEast);
+        reportedPosition.setY(trueSimulatedGnssPos.getY() + offsetNorth);
+
+        // Save for next frame's recovery calculation
+        lastReportedPosition = reportedPosition;
+
+        // Convert reported position to GPS coordinates for logging
+        xyz_t reportedEnu = {reportedPosition.getX(), reportedPosition.getY(), reportedPosition.getHeight()};
+        llh_t reportedGps = coordinateTransforms::enuToLlh(enuRef, reportedEnu);
+
+        // Check what zone the reported (possibly spoofed) position reports
+        double reportedZoneSpeed = getSpeedLimitAtPosition(reportedGps.longitude, reportedGps.latitude,
+                                                          config.speedLimitRegions);
+
+        // Log attack progress periodically
+        config.spoofedUpdates++;
+        if (config.spoofedUpdates % 40 == 0) {  // Every ~1 second at 25ms updates
+            qWarning() << "[ATTACK] Spoofing" << (config.spoofState != SPOOF_OFF ? "ACTIVE" : "NO")
+                       << "- Progress:" << (config.transitionProgress * 100.0) << "%";
+            qWarning() << "  Real position:" << currentGps.latitude << "," << currentGps.longitude;
+            qWarning() << "  Real zone: " << config.currentSpeedLimit << "km/h";
+            qWarning() << "  Spoofed position:" << reportedGps.latitude << "," << reportedGps.longitude;
+            qWarning() << "  Spoofed zone: " << reportedZoneSpeed << "km/h";
+            qWarning() << "  Vehicle speed:" << (objectState->getSpeed() * 3.6) << "km/h";
+
+            // Track max speed
+            if (objectState->getSpeed() > config.maxSpeedAchieved) {
+                config.maxSpeedAchieved = objectState->getSpeed();
+            }
+
+            // Detect unsafe speeds: vehicle going >30 km/h while ACTUALLY in 30 km/h zone
+            double currentSpeedKmh = objectState->getSpeed() * 3.6;
+            if (config.currentSpeedLimit == 30.0 &&     // Real position in 30 km/h zone
+                reportedZoneSpeed == 80.0 &&             // Reported position in 80 km/h zone
+                currentSpeedKmh > 33.0) {               // Speed exceeds 30 km/h (10% tolerance)
+
+                if (!config.unsafeSpeedDetected) {
+                    qCritical() << "";
+                    qCritical() << "╔════════════════════════════════════════════════════════════╗";
+                    qCritical() << "║  [VULNERABILITY CONFIRMED] SPEED LIMIT BYPASS!            ║";
+                    qCritical() << "╚════════════════════════════════════════════════════════════╝";
+                    qCritical() << "[CRITICAL] Vehicle exceeding safe speed in restricted zone!";
+                    qCritical() << "[CRITICAL] ACTUAL zone limit: 30 km/h";
+                    qCritical() << "[CRITICAL] REPORTED zone limit:" << reportedZoneSpeed << "km/h";
+                    qCritical() << "[CRITICAL] Current speed:" << currentSpeedKmh << "km/h";
+                    qCritical() << "[CRITICAL] Speed limit enforcement BYPASSED via GNSS spoofing!";
+                    qCritical() << "";
+                    config.unsafeSpeedDetected = true;
+                }
+            }
+        }
+    }
+
+    // INJECT (POSSIBLY SPOOFED) POSITION INTO VEHICLE STATE
+    objectState->setPosition(reportedPosition);
+
     // ========================================================================
     // SECURITY LAYER: VALIDATE GNSS POSITION
     // ========================================================================
@@ -572,6 +878,10 @@ int main(int argc, char *argv[])
     qInfo() << "  Failsafe Threshold:" << positionValidator.config.failsafeThreshold << "consecutive failures";
     qInfo() << "  Anomaly Detection:" << (positionValidator.config.enableAnomalyDetection ? "Enabled" : "Disabled");
     qInfo() << "";
+
+    // Load speed limit regions
+    attackConfig.speedLimitRegions = loadSpeedLimitRegions(config.speedLimitRegionsFilePath);
+
     QTimer mUpdateVehicleStateTimer;
     QSharedPointer<TruckState> mTruckState = QSharedPointer<TruckState>::create(config.truckId);
     mTruckState->setLength(config.truckLength);
@@ -648,7 +958,6 @@ int main(int argc, char *argv[])
                 RtcmClient rtcmClient;
                 QObject::connect(mUbloxRover.get(), &UbloxRover::gotNmeaGga, &rtcmClient, &RtcmClient::forwardNmeaGgaToServer);
                 QObject::connect(&rtcmClient, &RtcmClient::rtcmData, mUbloxRover.get(), &UbloxRover::writeRtcmToUblox);
-                // QObject::connect(&rtcmClient, &RtcmClient::baseStationPosition, mTruckState.get(), &TruckState::setEnuRef);
                 if (rtcmClient.connectWithInfoFromFile(config.rtcmInfoFilePath))
                     qDebug() << "RtcmClient: connected to" << QString(rtcmClient.getCurrentHost()+ ":" + QString::number(rtcmClient.getCurrentPort()));
                 else
@@ -679,7 +988,7 @@ int main(int argc, char *argv[])
                 [&](QTime simTime_, QSharedPointer<ObjectState> objectState_) -> GnssFixStatus
                 {
                     return secureGnssProcessingFn(simTime_, objectState_, noise_pos, noise_yaw, rng,
-                                                  positionValidator, lastGnssUpdateTime);
+                                                  positionValidator, lastGnssUpdateTime, attackConfig);
                 }
             );
         });
@@ -774,7 +1083,7 @@ int main(int argc, char *argv[])
         const PosPoint odomPosition = mTruckState->getPosition(PosType::odom);
         const PosPoint targetWaypoint = mWaypointFollower->getCurrentGoal();

-        QString textToAppend = QString("%1 | Current speed = %2 m/s | Odom position: X = %3 Y = %4 Yaw = %5 | GNSS position: X = %6 Y = %7 Yaw = %8 | Target waypoint: X = %9 Y = %10 Speed = %11 | Security Events = %12\n")
+        QString textToAppend = QString("%1 | Current speed = %2 m/s | Odom position: X = %3 Y = %4 Yaw = %5 | GNSS position: X = %6 Y = %7 Yaw = %8 | Target waypoint: X = %9 Y = %10 Speed = %11 | Spoof State = %12 | Security Events = %13\n")
                                    .arg(QDateTime::currentDateTime().toString("dd-MM-yyyy hh:mm:ss"))
                                    .arg(speed)
                                    .arg(odomPosition.getX())
@@ -786,6 +1095,7 @@ int main(int argc, char *argv[])
                                    .arg(targetWaypoint.getX())
                                    .arg(targetWaypoint.getY())
                                    .arg(targetWaypoint.getSpeed())
+                                   .arg(getSpoofStateName(attackConfig.spoofState))
                                    .arg(positionValidator.getNewSecurityEventCount());

         logFile->write(textToAppend.toLocal8Bit());
