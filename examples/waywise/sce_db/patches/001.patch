diff --git a/GNSS_SPOOFING_ATTACK.md b/GNSS_SPOOFING_ATTACK.md
new file mode 100644
index 0000000..4077ce4
--- /dev/null
+++ b/GNSS_SPOOFING_ATTACK.md
@@ -0,0 +1,400 @@
+# GNSS Spoofing Attack - Technical Documentation
+
+## Overview
+
+This document describes the targeted GNSS spoofing attack implementation in `main.cpp` that demonstrates a critical vulnerability in the WayWise autonomous vehicle system. The attack exploits the lack of GNSS position validation to bypass speed limit enforcement.
+
+## Attack Concept
+
+### Vulnerability
+
+The WayWise system relies on GNSS position data to determine the current speed limit zone and enforce appropriate speed restrictions. By spoofing the GNSS position, an attacker can make the vehicle appear to be in a different speed limit zone, causing the system to apply incorrect speed limits.
+
+### Attack Strategy
+
+1. **Vehicle drives in 30 km/h zone** (actual location)
+2. **Spoof GNSS to report position in 80 km/h zone** (fake location)
+3. **System applies 80 km/h speed limit** (based on fake position)
+4. **Vehicle exceeds safe speed** (traveling at 80 km/h in actual 30 km/h zone)
+
+### Real-World Impact
+
+- **Safety Risk**: Vehicle traveling at unsafe speeds in restricted zones (e.g., school zones, residential areas)
+- **Regulatory Violation**: Speed limit enforcement completely bypassed
+- **Collision Risk**: Excessive speed in areas with pedestrians, cyclists, or other vulnerable road users
+
+## Implementation Architecture
+
+### File Structure
+
+```text
+precise-truck/
+├── main.cpp                          # Main implementation
+├── GNSS_SPOOFING_ATTACK.md          # This documentation
+└── config/
+    ├── speedLimitRegions.json        # Speed limit zone polygons
+    └── truck1.json                   # Vehicle configuration
+```
+
+### Key Components
+
+#### 1. Attack Configuration (`AttackConfig` struct)
+
+```cpp
+struct AttackConfig {
+    // Attack parameters
+    bool attackEnabled = true;
+    double attackStartTime = 5.0;              // Delay before attack starts
+    double attackDuration = 5.0;               // How long attack lasts
+
+    // Spoofing offsets (meters in ENU coordinates)
+    double spoofingOffsetEast = -20.0;         // East offset
+    double spoofingOffsetNorth = 40.0;         // North offset
+
+    // Transition timing
+    double attackTransitionDuration = 2.0;     // Attack ramp-up time
+    double recoveryOffsetReductionRate = 0.1;  // Recovery speed (m/update)
+
+    // Speed limit zones
+    QVector<SpeedLimitPolygon> speedLimitRegions;
+    double targetSpeedLimit = 30.0;            // Zone to attack from
+
+    // Internal State
+    SpoofState spoofState = SPOOF_OFF;         // Current attack phase
+};
+```
+
+#### 2. Attack State Machine (`SpoofState` enum)
+
+The attack logic is managed by a robust 4-state machine:
+
+- `SPOOF_OFF`: Normal operation (monitoring)
+- `SPOOF_WARM_UP`: Transitioning from real to spoofed position
+- `SPOOF_ACTIVE`: Fully spoofed position (sustained attack)
+- `SPOOF_COOL_DOWN`: Recovering to real position
+
+#### 3. Attack Function (`targetedGnssSpoofingAttackFn`)
+
+The main attack logic is implemented as a lambda function that:
+
+- Maintains true vehicle position internally
+- Applies spoofing offsets during attack
+- Handles smooth transitions and recovery
+- Logs attack progress and detects unsafe conditions
+
+## Attack Phases
+
+### Phase 1: Monitoring (0-5 seconds)
+
+**Purpose**: Wait for vehicle to reach target zone and verify conditions
+
+**Behavior**:
+
+- Track vehicle's true position using odometry
+- Determine current speed limit zone via polygon detection
+- Wait for configured delay (`attackStartTime`)
+- Verify vehicle is in 30 km/h zone
+
+**Logging**:
+
+```text
+[DEBUG] Position: 57.7172, 12.9628 | Zone speed limit: 30 km/h | Spoof State: OFF
+```
+
+### Phase 2: Attack Initiation (5-7 seconds)
+
+**Purpose**: Smoothly transition from true position to spoofed position (`SPOOF_WARM_UP`)
+
+**Behavior**:
+
+- Activate attack when vehicle enters 30 km/h zone
+- Gradually increase spoofing offset over 2 seconds
+- Use linear scaling: `offset = configuredOffset × transitionProgress`
+- `transitionProgress` ramps from 0.0 to 1.0
+
+**Logging**:
+
+```text
+╔════════════════════════════════════════════════════════════╗
+║  [ATTACK INITIATED] GNSS SPOOFING ATTACK STARTED          ║
+╚════════════════════════════════════════════════════════════╝
+[ATTACK] Vehicle is in 30 km/h zone (as planned)
+[ATTACK] Real position: 57.7172, 12.9628
+[ATTACK] Initiating position spoofing to bypass speed limits...
+```
+
+**Progress Updates**:
+
+```text
+[ATTACK] Spoofing WARM_UP - Progress: 50%
+  Real position: 57.7173, 12.9633
+  Real zone: 30 km/h
+  Spoofed position: 57.7175, 12.9631
+  Spoofed zone: 80 km/h
+  Vehicle speed: 80 km/h
+```
+
+### Phase 3: Sustained Attack (7-12 seconds)
+
+**Purpose**: Maintain spoofed position for attack duration (`SPOOF_ACTIVE`)
+
+**Behavior**:
+
+- Keep `transitionProgress = 1.0` (fully spoofed)
+- Report position offset by full configured amount
+- Monitor for unsafe speed conditions
+- Track maximum speed achieved
+
+**Vulnerability Detection**:
+
+```text
+╔════════════════════════════════════════════════════════════╗
+║  [VULNERABILITY CONFIRMED] SPEED LIMIT BYPASS!            ║
+╚════════════════════════════════════════════════════════════╝
+[CRITICAL] Vehicle exceeding safe speed in restricted zone!
+[CRITICAL] ACTUAL zone limit: 30 km/h
+[CRITICAL] REPORTED zone limit: 80 km/h
+[CRITICAL] Current speed: 80 km/h
+```
+
+### Phase 4: Attack End (12 seconds)
+
+**Purpose**: Terminate attack after configured duration
+
+**Behavior**:
+
+- Transition state to `SPOOF_COOL_DOWN`
+- Capture current offset for recovery
+- Begin velocity-based recovery
+
+**Logging**:
+
+```text
+╔════════════════════════════════════════════════════════════╗
+║  [ATTACK ENDED] Duration limit reached                    ║
+╚════════════════════════════════════════════════════════════╝
+[ATTACK] Total spoofed updates: 199
+[ATTACK] Max speed achieved: 80 km/h
+[ATTACK] Unsafe speed detected: YES
+```
+
+### Phase 5: Recovery (12+ seconds, adaptive duration)
+
+**Purpose**: Smoothly converge back to true position (`SPOOF_COOL_DOWN`) without causing vehicle slowdown
+
+**Behavior**:
+
+- **Velocity-Based Recovery**: Offset reduces by fixed amount per frame
+- Reduction rate: `0.1 m/update` = `4 m/s` convergence speed
+- Reported position continues moving forward with vehicle
+- Recovery completes when offset magnitude < 0.01m
+
+**Key Innovation**: Unlike time-based interpolation, velocity-based recovery ensures the reported GNSS position continues moving forward with the vehicle, preventing the position fuser from detecting slowdown.
+
+**Logging**:
+
+```text
+[ATTACK] Recovery initiated. Initial offset: -20.1976 E, 39.9325 N | Magnitude: 44.7 m
+[ATTACK] Spoofing COOL_DOWN - Progress: 79.5%
+[ATTACK] Spoofing COOL_DOWN - Progress: 59.5%
+[ATTACK] Spoofing COOL_DOWN - Progress: 39.5%
+[ATTACK] Spoofing COOL_DOWN - Progress: 19.5%
+[ATTACK] Recovery complete - using real GNSS position
+```
+
+**Recovery Duration Calculation**:
+
+- Offset magnitude: ~45 meters
+- Reduction rate: 0.1 m/update
+- Updates needed: 45 ÷ 0.1 = 450 updates
+- Time at 25ms/update: 450 × 0.025s = **11.25 seconds**
+
+## Technical Details
+
+### Position Tracking
+
+#### True Position (Internal Ground Truth)
+
+```cpp
+static PosPoint trueSimulatedGnssPos;  // Maintained internally
+```
+
+- Updated each frame based on odometry deltas
+- Never affected by spoofing offsets
+- Used for zone detection and recovery calculations
+
+#### Reported Position (Spoofed)
+
+```cpp
+PosPoint reportedPosition = trueSimulatedGnssPos;
+reportedPosition.setX(trueSimulatedGnssPos.getX() + offsetEast);
+reportedPosition.setY(trueSimulatedGnssPos.getY() + offsetNorth);
+```
+
+- True position + spoofing offset
+- Injected into vehicle state
+- Used by position fuser and control systems
+
+### Coordinate Systems
+
+**ENU (East-North-Up)**:
+
+- Local Cartesian coordinates
+- Origin at configured reference point (57.7172°N, 12.9628°E)
+- Spoofing offsets applied in ENU frame
+
+**LLH (Latitude-Longitude-Height)**:
+
+- GPS coordinates
+- Used for zone detection and logging
+- Converted from ENU for display
+
+### Speed Limit Zone Detection
+
+```cpp
+double getSpeedLimitAtPosition(double longitude, double latitude,
+                               const QVector<SpeedLimitPolygon>& regions)
+```
+
+**Algorithm**:
+
+1. Convert GPS coordinates to polygon coordinate system
+2. Perform point-in-polygon test for each region
+3. Return speed limit of containing region
+4. Return -1 if no region contains the point
+
+**Polygon Data**: Loaded from `config/speedLimitRegions.json`
+
+## Configuration
+
+### Attack Parameters
+
+| Parameter                     | Default        | Description                      |
+| ----------------------------- | -------------- | -------------------------------- |
+| `attackEnabled`               | `true`         | Enable/disable attack            |
+| `attackStartTime`             | `5.0s`         | Delay before attack starts       |
+| `attackDuration`              | `5.0s`         | How long attack lasts            |
+| `spoofingOffsetEast`          | `-20.0m`       | East offset (towards expressway) |
+| `spoofingOffsetNorth`         | `40.0m`        | North offset                     |
+| `attackTransitionDuration`    | `2.0s`         | Attack ramp-up time              |
+| `recoveryOffsetReductionRate` | `0.1 m/update` | Recovery convergence speed       |
+
+### Tuning Recovery Speed
+
+**Current Setting**: `0.1 m/update` = `4 m/s` recovery
+
+**Faster Recovery**:
+
+```cpp
+double recoveryOffsetReductionRate = 0.5;  // 20 m/s, ~2.25s for 45m offset
+```
+
+**Slower Recovery**:
+
+```cpp
+double recoveryOffsetReductionRate = 0.05; // 2 m/s, ~22.5s for 45m offset
+```
+
+**Instant Recovery**:
+
+```cpp
+double recoveryOffsetReductionRate = 100.0; // Immediate snap back
+```
+
+## Testing & Validation
+
+### Running the Attack
+
+1. **Start ControlTower**:
+
+   ```bash
+   cd /home/avula/workspaces/precise_ws/src/ControlTower/build
+   ./ControlTower
+   ```
+
+2. **Start RCTruck with attack enabled**:
+
+   ```bash
+   cd /home/avula/workspaces/precise_ws/src/precise-truck/build
+   ./RCTruck --config ../config/truck1.json
+   ```
+
+3. **Observe the attack phases** in the console output
+
+### Expected Behavior
+
+✅ **Attack Initiation**: Vehicle in 30 km/h zone, attack starts after 5s
+✅ **Speed Increase**: Vehicle accelerates to 80 km/h
+✅ **Vulnerability Confirmed**: Critical warning logged
+✅ **Smooth Recovery**: Vehicle converges back to true position without pausing
+✅ **No Jumps**: Position transitions are smooth throughout
+
+### Success Criteria
+
+- [ ] Attack triggers when vehicle is in 30 km/h zone
+- [ ] Spoofed position reports 80 km/h zone
+- [ ] Vehicle achieves 80 km/h speed
+- [ ] Unsafe speed detected and logged
+- [ ] Recovery completes without vehicle slowdown
+- [ ] No position jumps or discontinuities
+
+## Security Implications
+
+### Demonstrated Vulnerabilities
+
+1. **No GNSS Authentication**: System accepts any GNSS signal without validation
+2. **No Multi-Sensor Fusion**: Position not cross-validated with IMU, odometry, or vision
+3. **No Anomaly Detection**: Sudden position changes not flagged as suspicious
+4. **No Geofencing**: No verification that reported position is physically reachable
+5. **No Rate Limiting**: Position can change faster than physically possible
+
+### Recommended Mitigations
+
+1. **GNSS Signal Authentication**
+   - Use authenticated GNSS signals (e.g., Galileo OS-NMA)
+   - Implement signal quality monitoring
+
+2. **Multi-Sensor Validation**
+   - Cross-validate GNSS with IMU dead reckoning
+   - Compare with visual odometry
+   - Use redundant positioning (RTK, UWB)
+
+3. **Anomaly Detection**
+   - Detect sudden position jumps
+   - Monitor for physically impossible velocities
+   - Track consistency between sensors
+
+4. **Geofence Breach Detection**
+   - Define expected route corridors
+   - Alert on unexpected position deviations
+   - Implement safe fallback behaviors
+
+5. **Secure Positioning Architecture**
+   - Implement position trust scores
+   - Use Kalman filter with outlier rejection
+   - Maintain position uncertainty estimates
+
+## References
+
+### Related Files
+
+- [`main.cpp`](file:///home/avula/workspaces/precise_ws/src/precise-truck/main.cpp) - Main implementation
+- [`config/speedLimitRegions.json`](file:///home/avula/workspaces/precise_ws/src/precise-truck/config/speedLimitRegions.json) - Zone definitions
+- [`velocity_recovery.md`](file:///home/avula/.gemini/antigravity/brain/97423448-04c4-4f9c-b4be-27ec2fd1bccf/velocity_recovery.md) - Recovery implementation details
+
+### Key Functions
+
+- `targetedGnssSpoofingAttackFn` (line 272) - Main attack logic
+- `getSpeedLimitAtPosition` (line 117) - Zone detection
+- `loadSpeedLimitRegionsFromJson` (line 117) - Configuration loading
+
+### Attack Configuration
+
+- `AttackConfig` struct (line 185) - All attack parameters
+- `attackConfig` global (line 232) - Active configuration instance
+
+---
+
+**Last Updated**: 2026-02-02
+**Version**: 1.0
+**Status**: Active Implementation
diff --git a/main.cpp b/main.cpp
index a07fdd1..8744298 100644
--- a/main.cpp
+++ b/main.cpp
@@ -1,3 +1,40 @@
+/**
+ * ============================================================================
+ * GNSS SPOOFING EXPLOIT - SIMULATION DEMONSTRATION
+ * ============================================================================
+ *
+ * PURPOSE:
+ * Demonstrates a critical vulnerability in the WayWise autonomous vehicle
+ * system where lack of GNSS validation allows targeted position spoofing
+ * attacks to bypass speed limit enforcement.
+ *
+ * ATTACK SCENARIO:
+ * - Vehicle drives through zones with different speed limits (30 km/h, 80 km/h)
+ * - Attacker spoofs GNSS position when vehicle enters low-speed zone
+ * - System believes vehicle is in high-speed zone, allows unsafe speeds
+ * - Demonstrates real-world safety impact of missing GNSS authentication
+ *
+ * VULNERABILITY:
+ * WayWise lacks GNSS signal authentication and position validation:
+ * - No cryptographic verification of GNSS signals
+ * - No anomaly detection for impossible position jumps
+ * - No multi-sensor fusion validation
+ * - Direct trust of GNSS data without cross-checking
+ *
+ * USAGE:
+ * This file replaces main.cpp and uses the same configuration files:
+ * - Route file: Defines waypoints the vehicle follows
+ * - Speed limit regions file: Defines geofenced speed zones
+ * - Vehicle config: Same parameters as normal operation
+ *
+ * The gaussianGnssPerturbationFn has been replaced with
+ * targetedGnssSpoofingAttackFn that demonstrates the exploit.
+ *
+ * BUILD: Same as main.cpp (see CMakeLists.txt in precise-truck/)
+ * RUN: ./RCTruck --config config/truck_config.json
+ * ============================================================================
+ */
+
 #include <QCoreApplication>
 #include <QSerialPortInfo>
 #include <QDateTime>
@@ -41,33 +78,238 @@ static void terminationSignalHandler(int signal) {
 // static std::mt19937 rng{std::random_device{}()};
 static std::mt19937 rng{12345};

-auto gaussianGnssPerturbationFn =
+// ============================================================================
+// POLYGON-BASED ZONE DETECTION
+// ============================================================================
+
+struct SpeedLimitPolygon {
+    QVector<QPointF> vertices;
+    double speedLimit;
+    int id;
+};
+
+bool isPointInPolygon(double lon, double lat, const QVector<QPointF>& polygon) {
+    int intersections = 0;
+    int n = polygon.size();
+
+    for (int i = 0; i < n; i++) {
+        QPointF p1 = polygon[i];
+        QPointF p2 = polygon[(i + 1) % n];
+
+        if (((p1.y() <= lat && lat < p2.y()) || (p2.y() <= lat && lat < p1.y())) &&
+            (lon < (p2.x() - p1.x()) * (lat - p1.y()) / (p2.y() - p1.y()) + p1.x())) {
+            intersections++;
+        }
+    }
+
+    return (intersections % 2) == 1;
+}
+
+QVector<SpeedLimitPolygon> loadSpeedLimitRegions(const QString& filePath) {
+    QVector<SpeedLimitPolygon> regions;
+
+    QFile file(filePath);
+    if (!file.open(QIODevice::ReadOnly)) {
+        qWarning() << "[SECURITY] Failed to open speed limit regions file:" << filePath;
+        return regions;
+    }
+
+    QByteArray data = file.readAll();
+    file.close();
+
+    QJsonDocument doc = QJsonDocument::fromJson(data);
+    if (!doc.isObject()) {
+        qWarning() << "[SECURITY] Invalid JSON format in speed limit regions file";
+        return regions;
+    }
+
+    QJsonObject root = doc.object();
+    QJsonArray features = root["features"].toArray();
+
+    for (const QJsonValue& featureVal : features) {
+        QJsonObject feature = featureVal.toObject();
+        QJsonObject properties = feature["properties"].toObject();
+        QJsonObject geometry = feature["geometry"].toObject();
+
+        SpeedLimitPolygon region;
+        region.speedLimit = properties["maxSpeed"].toDouble();
+        region.id = feature["id"].toInt();
+
+        QJsonArray coordinates = geometry["coordinates"].toArray();
+        if (!coordinates.isEmpty()) {
+            QJsonArray polygonCoords = coordinates[0].toArray();
+
+            for (const QJsonValue& pointVal : polygonCoords) {
+                QJsonArray point = pointVal.toArray();
+                if (point.size() >= 2) {
+                    double lon = point[0].toDouble();
+                    double lat = point[1].toDouble();
+                    region.vertices.append(QPointF(lon, lat));
+                }
+            }
+
+            regions.append(region);
+        }
+    }
+
+    return regions;
+}
+
+double getSpeedLimitAtPosition(double lon, double lat, const QVector<SpeedLimitPolygon>& regions) {
+    for (const auto& region : regions) {
+        if (isPointInPolygon(lon, lat, region.vertices)) {
+            return region.speedLimit;
+        }
+    }
+    return -1.0;
+}
+
+
+// ============================================================================
+// ATTACK CONFIGURATION
+// ============================================================================
+enum SpoofState {
+    SPOOF_OFF,
+    SPOOF_WARM_UP,
+    SPOOF_ACTIVE,
+    SPOOF_COOL_DOWN
+};
+
+static const char* getSpoofStateName(SpoofState state) {
+    switch (state) {
+        case SPOOF_OFF: return "OFF";
+        case SPOOF_WARM_UP: return "WARM_UP";
+        case SPOOF_ACTIVE: return "ACTIVE";
+        case SPOOF_COOL_DOWN: return "COOL_DOWN";
+        default: return "UNKNOWN";
+    }
+}
+
+struct AttackConfig {
+    bool attackEnabled = true;              // Enable/disable attack
+    double attackStartTime = 5.0;          // Start attack after N seconds
+    double attackDuration = 5.0;           // Duration of attack in seconds
+
+    // Speed limit regions loaded from JSON
+    QVector<SpeedLimitPolygon> speedLimitRegions;
+
+    // Attack trigger: Activate when vehicle is in 30 km/h zone
+    // Vehicle route stays in 30 km/h zone, we spoof to 80 km/h zone
+    double targetSpeedLimit = 30.0;         // Real zone vehicle is in
+
+    // Spoofing strategy: Vehicle is ACTUALLY in 30 km/h zone,
+    // spoof position to make it APPEAR in 80 km/h expressway zone
+    double spoofingOffsetEast = -20.0;      // Offset in meters (towards expressway)
+    double spoofingOffsetNorth = 40.0;      // Offset in meters
+    bool smoothTransition = true;           // Gradually spoof to avoid detection
+    double attackTransitionDuration = 2.0;  // Seconds to transition into attack
+
+    // Recovery configuration: velocity-based offset reduction
+    // Offset reduces by a fixed amount per frame (meters/update)
+    // Smaller values = slower, smoother recovery
+    // At 25ms updates: 0.1 m/update = 4 m/s recovery speed
+    // Recovery duration depends on offset magnitude (adaptive)
+    double recoveryOffsetReductionRate = 0.1; // meters per update (0.025s)
+
+    // Attack state
+    SpoofState spoofState = SPOOF_OFF;
+    bool attackTriggered = false;           // True once attack has been initiated
+    double attackElapsedTime = 0.0;
+    double transitionProgress = 0.0;        // 0.0 = real position, 1.0 = fully spoofed
+    xyz_t spoofingOffset = {0.0, 0.0, 0.0};
+
+    // Recovery state
+    double recoveryOffsetEast = 0.0;
+    double recoveryOffsetNorth = 0.0;
+    bool recoveryCaptured = false;
+
+    // Track current zone
+    double currentSpeedLimit = -1.0;
+    double previousSpeedLimit = -1.0;
+
+    // Statistics
+    int spoofedUpdates = 0;
+    double maxSpeedAchieved = 0.0;
+    bool unsafeSpeedDetected = false;
+    llh_t attackStartPosition = {0.0, 0.0, 0.0};
+};
+
+static AttackConfig attackConfig;
+
+/**
+ * ============================================================================
+ * TARGETED GNSS SPOOFING ATTACK FUNCTION (POLYGON-BASED)
+ * ============================================================================
+ *
+ * This function replaces gaussianGnssPerturbationFn to demonstrate a
+ * realistic GNSS spoofing attack using actual speed limit regions.
+ *
+ * ATTACK STRATEGY:
+ * 1. Vehicle drives along planned route (entirely in 30 km/h zone)
+ * 2. Monitor vehicle's true position and determine current speed limit zone
+ * 3. When vehicle is in 30 km/h zone, activate attack after delay
+ * 4. Spoof GNSS position to make vehicle APPEAR in 80 km/h expressway zone
+ * 5. System sees fake position in 80 km/h zone → allows higher speeds
+ * 6. Vehicle exceeds actual 30 km/h speed limit (UNSAFE!)
+ *
+ * ATTACK PHASES:
+ * - Monitoring: Verify vehicle is in 30 km/h zone (as expected)
+ * - Trigger: After configured delay, activate attack
+ * - Attack Transition: Gradually spoof position into 80 km/h zone (2 seconds)
+ * - Sustained: Maintain spoofed position for attack duration
+ * - Recovery: Velocity-based convergence back to true position (adaptive duration)
+ *
+ * REAL vs FAKE:
+ * - Real position: In 30 km/h zone (actual vehicle location)
+ * - Fake position: In 80 km/h zone (spoofed GNSS signal)
+ * - System uses: Fake position → allows unsafe speeds
+ *
+ * PARAMETERS:
+ * - simTime: Current simulation time
+ * - vehicleState: Vehicle state object with position data
+ * - config: Attack configuration and state
+ *
+ * RETURNS:
+ * - GnssFixStatus with spoofed or true position data
+ */
+auto targetedGnssSpoofingAttackFn =
 [](QTime simTime,
    QSharedPointer<ObjectState> objectState,
    std::normal_distribution<double>& noise_pos,
    std::normal_distribution<double>& noise_yaw,
-   std::mt19937& rng)
+   std::mt19937& rng,
+   AttackConfig& config)
 {
-    Q_UNUSED(simTime);
+    // Maintain true simulated position internally to avoid accumulation of spoofing offsets
+    static PosPoint trueSimulatedGnssPos;
     static PosPoint lastOdomPosPoint;
-    PosPoint gnssPosPoint = objectState->getPosition(PosType::GNSS);
+    static bool initialized = false;
+
     PosPoint odomPosPoint = objectState->getPosition(PosType::odom);

+    if (!initialized) {
+        trueSimulatedGnssPos = objectState->getPosition(PosType::GNSS);
+        lastOdomPosPoint = odomPosPoint;
+        initialized = true;
+    }
+
+    // Calculate movement delta from odometry
     double deltaX = odomPosPoint.getX() - lastOdomPosPoint.getX() + noise_pos(rng);
     double deltaY = odomPosPoint.getY() - lastOdomPosPoint.getY() + noise_pos(rng);
     double deltaYaw = odomPosPoint.getYaw() - lastOdomPosPoint.getYaw() + noise_yaw(rng);
-    gnssPosPoint.setX(gnssPosPoint.getX() + deltaX);
-    gnssPosPoint.setY(gnssPosPoint.getY() + deltaY);
-    double yawResult = gnssPosPoint.getYaw() + deltaYaw;
+
+    // Update TRUE internal simulated position (no spoofing applied here)
+    trueSimulatedGnssPos.setX(trueSimulatedGnssPos.getX() + deltaX);
+    trueSimulatedGnssPos.setY(trueSimulatedGnssPos.getY() + deltaY);
+    double yawResult = trueSimulatedGnssPos.getYaw() + deltaYaw;

     while (yawResult < -180.0)
         yawResult += 360.0;
     while (yawResult >= 180.0)
         yawResult -= 360.0;

-    gnssPosPoint.setYaw(yawResult);
-    gnssPosPoint.setTime(odomPosPoint.getTime());
-    objectState->setPosition(gnssPosPoint);
+    trueSimulatedGnssPos.setYaw(yawResult);
+    trueSimulatedGnssPos.setTime(odomPosPoint.getTime());

     GnssFixStatus gnssFixStatus;
     gnssFixStatus.isFusedOnChip = true;
@@ -80,6 +322,236 @@ auto gaussianGnssPerturbationFn =

     lastOdomPosPoint = odomPosPoint;

+    // Get ENU reference for coordinate conversions
+    llh_t enuRef = objectState->getEnuRef();
+
+    // Convert true internal position to GPS coordinates for zone detection
+    xyz_t currentEnu = {trueSimulatedGnssPos.getX(), trueSimulatedGnssPos.getY(), trueSimulatedGnssPos.getHeight()};
+    llh_t currentGps = coordinateTransforms::enuToLlh(enuRef, currentEnu);
+
+    // Determine which speed limit zone the vehicle is ACTUALLY in
+    config.previousSpeedLimit = config.currentSpeedLimit;
+    config.currentSpeedLimit = getSpeedLimitAtPosition(currentGps.longitude, currentGps.latitude,
+                                                       config.speedLimitRegions);
+
+    // Debug: Log zone detection periodically
+    static int debugCounter = 0;
+    if (debugCounter++ % 200 == 0) {  // Every ~5 seconds
+        qWarning() << "[DEBUG] Position:" << currentGps.latitude << "," << currentGps.longitude
+                   << "| Zone speed limit:" << config.currentSpeedLimit << "km/h"
+                   << "| Attack state:" << config.spoofState;
+    }
+
+    // Log when zone changes
+    if (config.currentSpeedLimit != config.previousSpeedLimit && config.previousSpeedLimit >= 0) {
+        qWarning() << "[ZONE CHANGE] Speed limit changed from" << config.previousSpeedLimit
+                   << "km/h to" << config.currentSpeedLimit << "km/h"
+                   << "at position" << currentGps.latitude << "," << currentGps.longitude;
+    }
+
+    // Update attack elapsed time
+    static QTime startTime = simTime;
+    double elapsedSeconds = startTime.msecsTo(simTime) / 1000.0;
+
+    // ========================================================================
+    // ATTACK DECISION LOGIC
+    // ========================================================================
+
+
+    if (config.attackEnabled && elapsedSeconds >= config.attackStartTime) {
+
+        // PHASE 1: Verify vehicle is in 30 km/h zone and start attack
+        if (config.currentSpeedLimit == 30.0 && config.spoofState == SPOOF_OFF && !config.attackTriggered) {
+
+            qWarning() << "";
+            qWarning() << "╔════════════════════════════════════════════════════════════╗";
+            qWarning() << "║  [ATTACK INITIATED] GNSS SPOOFING ATTACK STARTED          ║";
+            qWarning() << "╚════════════════════════════════════════════════════════════╝";
+            qWarning() << "[ATTACK] Vehicle is in 30 km/h zone (as planned)";
+            qWarning() << "[ATTACK] Real position:" << currentGps.latitude << "," << currentGps.longitude;
+            qWarning() << "[ATTACK] Real speed limit: 30 km/h";
+            qWarning() << "[ATTACK] Initiating position spoofing to bypass speed limits...";
+            qWarning() << "[ATTACK] Goal: Make vehicle appear in 80 km/h zone";
+            qWarning() << "[ATTACK] Expected: System allows vehicle to exceed 30 km/h limit";
+            qWarning() << "";
+
+            config.spoofState = SPOOF_WARM_UP;
+            config.attackTriggered = true;
+            config.attackStartPosition = currentGps;
+        }
+
+        // Warning if zone detection is failing
+        if (!config.attackTriggered && config.currentSpeedLimit < 0) {
+            static bool warnedOnce = false;
+            if (!warnedOnce) {
+                qWarning() << "[ATTACK WARNING] Vehicle position not detected in any speed limit zone!";
+                qWarning() << "[ATTACK WARNING] Current position:" << currentGps.latitude << "," << currentGps.longitude;
+                qWarning() << "[ATTACK WARNING] This may indicate polygon detection issues.";
+                warnedOnce = true;
+            }
+        }
+
+        // PHASE 2: Continue attack if active
+        if (config.spoofState == SPOOF_ACTIVE) {
+
+            // Check attack duration limit
+            config.attackElapsedTime += 0.025;  // Assume 25ms update rate
+            if (config.attackElapsedTime > config.attackDuration) {
+                qWarning() << "";
+                qWarning() << "╔════════════════════════════════════════════════════════════╗";
+                qWarning() << "║  [ATTACK ENDED] Duration limit reached                    ║";
+                qWarning() << "╚════════════════════════════════════════════════════════════╝";
+                qWarning() << "[ATTACK] Total spoofed updates:" << config.spoofedUpdates;
+                qWarning() << "[ATTACK] Max speed achieved:" << (config.maxSpeedAchieved * 3.6) << "km/h";
+                qWarning() << "[ATTACK] Unsafe speed detected:" << (config.unsafeSpeedDetected ? "YES" : "NO");
+                qWarning() << "";
+                config.spoofState = SPOOF_COOL_DOWN;
+            }
+        }
+    }
+
+    // State for smooth recovery merging
+    static PosPoint lastReportedPosition;
+
+    // ========================================================================
+    // ATTACK EXECUTION
+    // ========================================================================
+
+    // Update transition progress (smooth spoofing to avoid detection)
+    if (config.spoofState == SPOOF_WARM_UP) {
+        config.recoveryCaptured = false;
+        if (config.smoothTransition) {
+            config.transitionProgress += 0.025 / config.attackTransitionDuration;
+            if (config.transitionProgress >= 1.0) {
+                config.transitionProgress = 1.0;
+                config.spoofState = SPOOF_ACTIVE;
+                qWarning() << "[ATTACK] Transition complete - fully spoofed position active";
+            }
+        } else {
+            config.transitionProgress = 1.0;
+            config.spoofState = SPOOF_ACTIVE;
+        }
+    } else if (config.spoofState == SPOOF_ACTIVE) {
+        config.recoveryCaptured = false;
+        // Fully spoofed state maintained
+    } else if (config.spoofState == SPOOF_COOL_DOWN) {
+        // Attack ended - use velocity-based recovery to converge to true position
+        if (config.transitionProgress > 0.0) {
+            // Capture the exact offset at the moment recovery starts
+            if (!config.recoveryCaptured) {
+                // Capture the offset between last reported position and current true position
+                // This offset will be reduced gradually using velocity-based recovery
+                config.recoveryOffsetEast = lastReportedPosition.getX() - trueSimulatedGnssPos.getX();
+                config.recoveryOffsetNorth = lastReportedPosition.getY() - trueSimulatedGnssPos.getY();
+                config.recoveryCaptured = true;
+
+                qWarning() << "[ATTACK] Recovery initiated. Initial offset:"
+                           << config.recoveryOffsetEast << "E," << config.recoveryOffsetNorth << "N"
+                           << "| Magnitude:" << std::sqrt(config.recoveryOffsetEast * config.recoveryOffsetEast +
+                                                          config.recoveryOffsetNorth * config.recoveryOffsetNorth) << "m";
+            }
+
+            // Reduce offset by a fixed amount each frame (velocity-based recovery)
+            // This ensures smooth convergence without causing vehicle slowdown
+            double offsetMagnitude = std::sqrt(config.recoveryOffsetEast * config.recoveryOffsetEast +
+                                               config.recoveryOffsetNorth * config.recoveryOffsetNorth);
+
+            if (offsetMagnitude > 0.01) {  // Continue until offset is negligible
+                // Calculate unit vector in direction of offset
+                double unitEast = config.recoveryOffsetEast / offsetMagnitude;
+                double unitNorth = config.recoveryOffsetNorth / offsetMagnitude;
+
+                // Reduce offset by fixed amount in the direction of the offset
+                double reductionAmount = std::min(config.recoveryOffsetReductionRate, offsetMagnitude);
+                config.recoveryOffsetEast -= unitEast * reductionAmount;
+                config.recoveryOffsetNorth -= unitNorth * reductionAmount;
+            } else {
+                // Recovery complete
+                config.recoveryOffsetEast = 0.0;
+                config.recoveryOffsetNorth = 0.0;
+                config.transitionProgress = 0.0;
+
+                qWarning() << "[ATTACK] Recovery complete - using real GNSS position";
+                config.attackElapsedTime = 0.0;
+                config.spoofedUpdates = 0;
+                config.spoofState = SPOOF_OFF;
+            }
+        }
+    }
+
+    PosPoint reportedPosition = trueSimulatedGnssPos;
+    if (config.spoofState != SPOOF_OFF || config.transitionProgress > 0.0) {
+        // Calculate spoofed offset
+        double offsetEast, offsetNorth;
+        if (config.spoofState != SPOOF_OFF && config.spoofState != SPOOF_COOL_DOWN) {
+            // During attack: scale configured goal offset
+            offsetEast = config.spoofingOffsetEast * config.transitionProgress;
+            offsetNorth = config.spoofingOffsetNorth * config.transitionProgress;
+        } else {
+            // During recovery: use the gradually reducing offset
+            // This ensures the GNSS position continues moving forward with the vehicle
+            // while smoothly converging to the true position
+            offsetEast = config.recoveryOffsetEast;
+            offsetNorth = config.recoveryOffsetNorth;
+        }
+
+        // Apply spoofing to TRUE internal position
+        reportedPosition.setX(trueSimulatedGnssPos.getX() + offsetEast);
+        reportedPosition.setY(trueSimulatedGnssPos.getY() + offsetNorth);
+
+        // Save for next frame's recovery calculation
+        lastReportedPosition = reportedPosition;
+
+        // Convert reported position to GPS coordinates for logging
+        xyz_t reportedEnu = {reportedPosition.getX(), reportedPosition.getY(), reportedPosition.getHeight()};
+        llh_t reportedGps = coordinateTransforms::enuToLlh(enuRef, reportedEnu);
+
+        // Check what zone the reported (possibly spoofed) position reports
+        double reportedZoneSpeed = getSpeedLimitAtPosition(reportedGps.longitude, reportedGps.latitude,
+                                                          config.speedLimitRegions);
+
+        // Log attack progress periodically
+        config.spoofedUpdates++;
+        if (config.spoofedUpdates % 40 == 0) {  // Every ~1 second at 25ms updates
+            qWarning() << "[ATTACK] Spoofing" << (config.spoofState != SPOOF_OFF ? "ACTIVE" : "NO")
+                       << "- Progress:" << (config.transitionProgress * 100.0) << "%";
+            qWarning() << "  Real position:" << currentGps.latitude << "," << currentGps.longitude;
+            qWarning() << "  Real zone: " << config.currentSpeedLimit << "km/h";
+            qWarning() << "  Spoofed position:" << reportedGps.latitude << "," << reportedGps.longitude;
+            qWarning() << "  Spoofed zone: " << reportedZoneSpeed << "km/h";
+            qWarning() << "  Vehicle speed:" << (objectState->getSpeed() * 3.6) << "km/h";
+
+            // Track max speed
+            if (objectState->getSpeed() > config.maxSpeedAchieved) {
+                config.maxSpeedAchieved = objectState->getSpeed();
+            }
+
+            // Detect unsafe speeds: vehicle going >30 km/h while ACTUALLY in 30 km/h zone
+            double currentSpeedKmh = objectState->getSpeed() * 3.6;
+            if (config.currentSpeedLimit == 30.0 &&     // Real position in 30 km/h zone
+                reportedZoneSpeed == 80.0 &&             // Reported position in 80 km/h zone
+                currentSpeedKmh > 33.0) {               // Speed exceeds 30 km/h (10% tolerance)
+
+                if (!config.unsafeSpeedDetected) {
+                    qCritical() << "";
+                    qCritical() << "╔════════════════════════════════════════════════════════════╗";
+                    qCritical() << "║  [VULNERABILITY CONFIRMED] SPEED LIMIT BYPASS!            ║";
+                    qCritical() << "╚════════════════════════════════════════════════════════════╝";
+                    qCritical() << "[CRITICAL] Vehicle exceeding safe speed in restricted zone!";
+                    qCritical() << "[CRITICAL] ACTUAL zone limit: 30 km/h";
+                    qCritical() << "[CRITICAL] REPORTED zone limit:" << reportedZoneSpeed << "km/h";
+                    qCritical() << "[CRITICAL] Current speed:" << currentSpeedKmh << "km/h";
+                    qCritical() << "[CRITICAL] Speed limit enforcement BYPASSED via GNSS spoofing!";
+                    qCritical() << "";
+                    config.unsafeSpeedDetected = true;
+                }
+            }
+        }
+    }
+
+    // INJECT (POSSIBLY SPOOFED) POSITION INTO VEHICLE STATE
+    objectState->setPosition(reportedPosition);
+
     return gnssFixStatus;
 };

@@ -207,7 +679,7 @@ TruckConfig parseArguments(QCoreApplication &app)
     TruckConfig config;

     QCommandLineParser parser;
-    parser.setApplicationDescription("RC Truck configuration");
+    parser.setApplicationDescription("RC Truck configuration - GNSS SPOOFING EXPLOIT DEMO");
     parser.addHelpOption();

     QCommandLineOption configFileOption({"c", "config"}, "Path to JSON config file.", "file");
@@ -272,6 +744,54 @@ int main(int argc, char *argv[])

     TruckConfig config = parseArguments(app);

+    // ========================================================================
+    // LOAD SPEED LIMIT REGIONS FOR ATTACK
+    // ========================================================================
+    qWarning() << "";
+    qWarning() << "[EXPLOIT] Loading speed limit regions from:" << config.speedLimitRegionsFilePath;
+    attackConfig.speedLimitRegions = loadSpeedLimitRegions(config.speedLimitRegionsFilePath);
+
+    if (attackConfig.speedLimitRegions.isEmpty()) {
+        qCritical() << "[EXPLOIT] ERROR: Failed to load speed limit regions!";
+        qCritical() << "[EXPLOIT] Attack cannot proceed without zone data.";
+        return 1;
+    }
+
+    qWarning() << "[EXPLOIT] Successfully loaded" << attackConfig.speedLimitRegions.size() << "speed limit regions";
+
+    // Verify polygon detection works by testing a known point
+    // Test point in the route (approximately where vehicle starts)
+    {
+        QStringList testParts = config.enuRef.split(",");
+        if (testParts.size() == 3) {
+            double lat = testParts[0].toDouble();
+            double lon = testParts[1].toDouble();
+            double testSpeed = getSpeedLimitAtPosition(lon, lat, attackConfig.speedLimitRegions);
+            qWarning() << "[EXPLOIT] Test detection at ENU reference (" << lat << "," << lon << "):";
+            qWarning() << "[EXPLOIT]   Speed limit:" << testSpeed << "km/h"
+                       << (testSpeed > 0 ? "(Detection working!)" : "(WARNING: Point not in any zone!)");
+        }
+    }
+    qWarning() << "";
+
+    qWarning() << "╔════════════════════════════════════════════════════════════╗";
+    qWarning() << "║                                                            ║";
+    qWarning() << "║       GNSS SPOOFING EXPLOIT - SIMULATION MODE              ║";
+    qWarning() << "║                                                            ║";
+    qWarning() << "║  Demonstrating WayWise vulnerability to GNSS spoofing     ║";
+    qWarning() << "║  attacks due to lack of position validation.              ║";
+    qWarning() << "║                                                            ║";
+    qWarning() << "╚════════════════════════════════════════════════════════════╝";
+    qWarning() << "";
+    qWarning() << "[EXPLOIT] ATTACK STRATEGY:";
+    qWarning() << "[EXPLOIT] 1. Vehicle route is in 30 km/h zone (actual position)";
+    qWarning() << "[EXPLOIT] 2. Spoof GNSS position to make vehicle APPEAR in 80 km/h zone";
+    qWarning() << "[EXPLOIT] 3. System sees fake position in 80 km/h zone";
+    qWarning() << "[EXPLOIT] 4. System allows vehicle to exceed actual 30 km/h limit";
+    qWarning() << "[EXPLOIT] 5. Vehicle travels at unsafe speed in 30 km/h zone (CRITICAL!)";
+    qWarning() << "[EXPLOIT] Attack duration: " << attackConfig.attackDuration << " seconds";
+    qWarning() << "";
+
     // --- Vehicle setup ---
     QTimer mUpdateVehicleStateTimer;
     QSharedPointer<TruckState> mTruckState = QSharedPointer<TruckState>::create(config.truckId);
@@ -360,22 +880,29 @@ int main(int argc, char *argv[])
         }
     }

+    // ========================================================================
+    // SIMULATION MODE WITH GNSS SPOOFING ATTACK
+    // ========================================================================
     if (!mGNSSReceiver) {
-        qDebug() << "No GNSS receiver connected. Simulating GNSS data.";
+        qWarning() << "[EXPLOIT] No hardware GNSS receiver connected.";
+        qWarning() << "[EXPLOIT] Using simulation mode with targeted GNSS spoofing attack.";
+        qWarning() << "";
+
         mGNSSReceiver.reset(new GNSSReceiver(mTruckState));
         mGNSSReceiver->setReceiverVariant(RECEIVER_VARIANT::WAYWISE_SIMULATED);
         mGNSSReceiver->setReceiverState(RECEIVER_STATE::READY);

+        // THIS IS WHERE THE ATTACK HAPPENS
         QObject::connect(mCarMovementController.get(), &CarMovementController::updatedOdomPositionAndYaw, [&](QSharedPointer<ObjectState> objectState, double distanceDriven){
             Q_UNUSED(objectState);
             Q_UNUSED(distanceDriven);
             static std::normal_distribution<double> noise_pos(0.0, config.gnssSimulationNoiseSigmaPos);
             static std::normal_distribution<double> noise_yaw(0.0, config.gnssSimulationNoiseSigmaYaw);
-
+            // Use targeted GNSS spoofing attack
             mGNSSReceiver->simulationStep(
                 [=](QTime simTime_, QSharedPointer<ObjectState> objectState_) mutable -> GnssFixStatus
                 {
-                    return gaussianGnssPerturbationFn(simTime_, objectState_, noise_pos, noise_yaw, rng);
+                    return targetedGnssSpoofingAttackFn(simTime_, objectState_,  noise_pos, noise_yaw, rng, attackConfig);
                 }
             );
         });
@@ -467,17 +994,22 @@ int main(int argc, char *argv[])
         // Parameters to log
         const double speed = mTruckState->getSpeed();
         const PosPoint gnssPosition = mTruckState->getPosition(PosType::fused);
+        const PosPoint odomPosition = mTruckState->getPosition(PosType::odom);
         const PosPoint targetWaypoint = mWaypointFollower->getCurrentGoal();

-        QString textToAppend = QString("%1 | Current speed = %2 m/s | GNSS position: X = %3 Y = %4 Yaw = %5 | Target waypoint: X = %6 Y = %7 Speed = %8\n")
+        QString textToAppend = QString("%1 | Current speed = %2 m/s | Odom position: X = %3 Y = %4 Yaw = %5 | GNSS position: X = %6 Y = %7 Yaw = %8 | Target waypoint: X = %9 Y = %10 Speed = %11 | Spoof State = %12\n")
                                    .arg(QDateTime::currentDateTime().toString("dd-MM-yyyy hh:mm:ss"))
                                    .arg(speed)
+                                   .arg(odomPosition.getX())
+                                   .arg(odomPosition.getY())
+                                   .arg(odomPosition.getYaw())
                                    .arg(gnssPosition.getX())
                                    .arg(gnssPosition.getY())
                                    .arg(gnssPosition.getYaw())
                                    .arg(targetWaypoint.getX())
                                    .arg(targetWaypoint.getY())
-                                   .arg(targetWaypoint.getSpeed());
+                                   .arg(targetWaypoint.getSpeed())
+                                   .arg(getSpoofStateName(attackConfig.spoofState));

         logFile->write(textToAppend.toLocal8Bit());
         logFile->flush();   // Ensures data is written
@@ -517,8 +1049,41 @@ int main(int argc, char *argv[])
     signal(SIGINT, terminationSignalHandler);
     QObject::connect(&app, &QCoreApplication::aboutToQuit, [&](){
         mGNSSReceiver->aboutToShutdown();
-        // ParameterServer::getInstance()->saveParametersToXmlFile("vehicle_parameters.xml");
+        ParameterServer::getInstance()->saveParametersToXmlFile("vehicle_parameters.xml");
         logFile->close();
+
+        // Print final attack statistics
+        if (attackConfig.spoofedUpdates > 0) {
+            qWarning() << "";
+            qWarning() << "╔════════════════════════════════════════════════════════════╗";
+            qWarning() << "║         ATTACK SUMMARY - FINAL STATISTICS                  ║";
+            qWarning() << "╚════════════════════════════════════════════════════════════╝";
+            qWarning() << "[SUMMARY] Total spoofed GNSS updates:" << attackConfig.spoofedUpdates;
+            qWarning() << "[SUMMARY] Maximum speed achieved:" << attackConfig.maxSpeedAchieved << "m/s ("
+                      << (attackConfig.maxSpeedAchieved * 3.6) << "km/h)";
+            qWarning() << "[SUMMARY] Unsafe speed detected:" << (attackConfig.unsafeSpeedDetected ? "YES" : "NO");
+
+            if (attackConfig.unsafeSpeedDetected) {
+                qCritical() << "";
+                qCritical() << "╔════════════════════════════════════════════════════════════╗";
+                qCritical() << "║  VULNERABILITY CONFIRMED - CRITICAL SAFETY ISSUE           ║";
+                qCritical() << "╚════════════════════════════════════════════════════════════╝";
+                qCritical() << "[RESULT] WayWise system is vulnerable to GNSS spoofing attacks!";
+                qCritical() << "[RESULT] Speed limit enforcement was successfully bypassed.";
+                qCritical() << "[RESULT] Vehicle exceeded safe speeds in restricted zone.";
+                qCritical() << "";
+                qCritical() << "RECOMMENDED MITIGATIONS:";
+                qCritical() << "1. Implement GNSS signal authentication";
+                qCritical() << "2. Add multi-sensor validation (IMU, odometry, vision)";
+                qCritical() << "3. Detect anomalous position jumps";
+                qCritical() << "4. Use redundant positioning (RTK, UWB)";
+                qCritical() << "5. Implement geofence breach detection";
+                qCritical() << "";
+            } else {
+                qInfo() << "[RESULT] No unsafe speeds detected during simulation.";
+                qInfo() << "[RESULT] Attack may not have been effective in this scenario.";
+            }
+        }
     });
     QObject::connect(&mavsdkVehicleServer, &MavsdkVehicleServer::shutdownOrRebootOnboardComputer, [&](bool isShutdown){
         qApp->quit();
